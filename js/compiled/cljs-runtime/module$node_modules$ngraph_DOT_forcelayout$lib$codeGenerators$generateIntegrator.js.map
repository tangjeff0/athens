{
"version":3,
"file":"module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$generateIntegrator.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,CAAe,gFAAf,CAAqG,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAW7IC,QAASA,+BAA8B,CAACC,SAAD,CAAY,CAC7CC,SAAAA,CAAUC,oBAAA,CAAqBF,SAArB,CAoCd,OAnCW,kFAmCX,CA/BEC,SAAA,CAAQ,mCAAR,CAAuC,CAACE,OAAQ,CAAT,CAAvC,CA+BF,CAnCW,8TAmCX;AAnBIF,SAAA,CAAQ,qDAAR,CAA4D,CAACE,OAAQ,CAAT,CAA5D,CAmBJ,CAnCW,QAmCX,CAlBIF,SAAA,CAAQ,sCAAR,CAA6C,CAACE,OAAQ,CAAT,CAA7C,CAkBJ,CAnCW,6BAmCX,CAjBsBF,SAAA,CAAQ,iBAAR,CAA2B,CAACG,KAAM,KAAP,CAA3B,CAiBtB,CAnCW,6KAmCX,CAZMH,SAAA,CAAQ,sCAAR,CAA6C,CAACE,OAAQ,CAAT,CAA7C,CAYN,CAnCW,iBAmCX,CATIF,SAAA,CAAQ,6CAAR;AAAoD,CAACE,OAAQ,CAAT,CAApD,CASJ,CAnCW,UAmCX,CAPIF,SAAA,CAAQ,8BAAR,CAAqC,CAACE,OAAQ,CAAT,CAArC,CAOJ,CAnCW,UAmCX,CALIF,SAAA,CAAQ,gCAAR,CAAuC,CAACE,OAAQ,CAAT,CAAvC,CAKJ,CAnCW,qBAmCX,CAFUF,SAAA,CAAQ,iBAAR,CAA2B,CAACG,KAAM,KAAP,CAA3B,CAEV,CAnCW,aAFsC,CAVnD,IAAMF,qBAAuBN,OAAA,CAAQ,oFAAR,CAE7BC,OAAA,CAAOC,OAAP,CAGAO,QAAmC,CAACL,SAAD,CAAY,CACzCM,SAAAA,CAAOP,8BAAA,CAA+BC,SAA/B,CACX,OAAO,KAAIO,QAAJ,CAAa,QAAb,CAAuB,UAAvB,CAAmC,wBAAnC,CAA6DD,SAA7D,CAFsC,CAF/CT;MAAA,CAAOC,OAAP,CAAeC,8BAAf,CAAgDA,8BAJ6F;",
"sources":["node_modules/ngraph_DOT_forcelayout/lib/codeGenerators/generateIntegrator.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$generateIntegrator\"] = function(global,require,module,exports) {\nconst createPatternBuilder = require('./createPatternBuilder');\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  let code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern('var d{var} = 0, t{var} = 0;', {indent: 2})}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${pattern('body.velocity.{var} += coeff * body.force.{var};', {indent: 4})}\n    ${pattern('var v{var} = body.velocity.{var};', {indent: 4})}\n    var v = Math.sqrt(${pattern('v{var} * v{var}', {join: ' + '})});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${pattern('body.velocity.{var} = v{var} / v;', {indent: 6})}\n    }\n\n    ${pattern('d{var} = timeStep * body.velocity.{var};', {indent: 4})}\n\n    ${pattern('body.pos.{var} += d{var};', {indent: 4})}\n\n    ${pattern('t{var} += Math.abs(d{var});', {indent: 4})}\n  }\n\n  return (${pattern('t{var} * t{var}', {join: ' + '})})/length;\n`\n  return code;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","generateIntegratorFunctionBody","dimension","pattern","createPatternBuilder","indent","join","generateIntegratorFunction","code","Function"]
}
