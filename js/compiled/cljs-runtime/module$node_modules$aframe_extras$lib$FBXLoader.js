shadow$provide.module$node_modules$aframe_extras$lib$FBXLoader=function(global,require,module,exports){module.exports=THREE.FBXLoader=function(){function FBXLoader(manager){this.manager=void 0!==manager?manager:THREE.DefaultLoadingManager}function FBXTreeParser(textureLoader){this.textureLoader=textureLoader}function GeometryParser(){}function AnimationParser(){}function TextParser(){}function BinaryParser(){}function BinaryReader(buffer,littleEndian){this.dv=new DataView(buffer);this.offset=0;this.littleEndian=
void 0!==littleEndian?littleEndian:!0}function FBXTree(){}function getFbxVersion(text){if(text=text.match(/FBXVersion: (\d+)/))return parseInt(text[1]);throw Error("THREE.FBXLoader: Cannot find the version number for the file given.");}function convertFBXTimeToSeconds(time){return time/46186158E3}function getData(polygonVertexIndex,polygonIndex,vertexIndex,infoObject){switch(infoObject.mappingType){case "ByPolygonVertex":var index=polygonVertexIndex;break;case "ByPolygon":index=polygonIndex;break;
case "ByVertice":index=vertexIndex;break;case "AllSame":index=infoObject.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+infoObject.mappingType)}"IndexToDirect"===infoObject.referenceType&&(index=infoObject.indices[index]);vertexIndex=index*infoObject.dataSize;polygonVertexIndex=dataArray;polygonIndex=infoObject.buffer;infoObject=vertexIndex+infoObject.dataSize;for(index=0;vertexIndex<infoObject;vertexIndex++,index++)polygonVertexIndex[index]=polygonIndex[vertexIndex];
return polygonVertexIndex}function generateTransform(transformData){var transform=new THREE.Matrix4;translation.set(0,0,0);rotation.identity();var order=transformData.eulerOrder?getEulerOrder(transformData.eulerOrder):getEulerOrder(0);transformData.translation&&translation.fromArray(transformData.translation);transformData.rotationOffset&&translation.add(tempVec.fromArray(transformData.rotationOffset));if(transformData.rotation){var array=transformData.rotation.map(THREE.Math.degToRad);array.push(order);
rotation.makeRotationFromEuler(tempEuler.fromArray(array))}transformData.preRotation&&(array=transformData.preRotation.map(THREE.Math.degToRad),array.push(order),tempMat.makeRotationFromEuler(tempEuler.fromArray(array)),rotation.premultiply(tempMat));transformData.postRotation&&(array=transformData.postRotation.map(THREE.Math.degToRad),array.push(order),tempMat.makeRotationFromEuler(tempEuler.fromArray(array)),tempMat.getInverse(tempMat),rotation.multiply(tempMat));transformData.scale&&transform.scale(tempVec.fromArray(transformData.scale));
transform.setPosition(translation);transform.multiply(rotation);return transform}function getEulerOrder(order){var enums="ZYX YZX XZY ZXY YXZ XYZ".split(" ");return 6===order?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),enums[0]):enums[order]}function parseNumberArray(value){return value.split(",").map(function(val){return parseFloat(val)})}function convertArrayBufferToString(buffer,from,to){void 0===from&&(from=0);void 0===to&&
(to=buffer.byteLength);return THREE.LoaderUtils.decodeText(new Uint8Array(buffer,from,to))}function append(a,b){for(var i=0,j=a.length,l=b.length;i<l;i++,j++)a[j]=b[i]}function inject(a1,index,a2){return a1.slice(0,index).concat(a2).concat(a1.slice(index))}var fbxTree,connections,sceneGraph;FBXLoader.prototype={constructor:FBXLoader,crossOrigin:"anonymous",load:function(url,onLoad,onProgress,onError){var self=this,resourceDirectory=THREE.LoaderUtils.extractUrlBase(url),loader=new THREE.FileLoader(this.manager);
loader.setResponseType("arraybuffer");loader.load(url,function(buffer){try{var scene=self.parse(buffer,resourceDirectory);onLoad(scene)}catch(error){setTimeout(function(){onError&&onError(error);self.manager.itemError(url)},0)}},onProgress,onError)},setCrossOrigin:function(value){this.crossOrigin=value;return this},parse:function(FBXBuffer,resourceDirectory){if(21<=FBXBuffer.byteLength&&"Kaydara FBX Binary  \x00"===convertArrayBufferToString(FBXBuffer,0,21))fbxTree=(new BinaryParser).parse(FBXBuffer);
else{FBXBuffer=convertArrayBufferToString(FBXBuffer);a:{var JSCompiler_inline_result=FBXBuffer;for(var CORRECT="Kaydara\\FBX\\Binary\\\\".split(""),cursor=0,i=0;i<CORRECT.length;++i){var result=JSCompiler_inline_result[0];JSCompiler_inline_result=JSCompiler_inline_result.slice(cursor+1);cursor++;if(result===CORRECT[i]){JSCompiler_inline_result=!1;break a}}JSCompiler_inline_result=!0}if(!JSCompiler_inline_result)throw Error("THREE.FBXLoader: Unknown format.");if(7E3>getFbxVersion(FBXBuffer))throw Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+
getFbxVersion(FBXBuffer));fbxTree=(new TextParser).parse(FBXBuffer)}resourceDirectory=(new THREE.TextureLoader(this.manager)).setPath(resourceDirectory).setCrossOrigin(this.crossOrigin);return(new FBXTreeParser(resourceDirectory)).parse(fbxTree)}};FBXTreeParser.prototype={constructor:FBXTreeParser,parse:function(){connections=this.parseConnections();var images=this.parseImages();images=this.parseTextures(images);images=this.parseMaterials(images);var deformers=this.parseDeformers(),geometryMap=(new GeometryParser).parse(deformers);
this.parseScene(deformers,geometryMap,images);return sceneGraph},parseConnections:function(){var connectionMap=new Map;"Connections"in fbxTree&&fbxTree.Connections.connections.forEach(function(rawConnection){var fromID=rawConnection[0],toID=rawConnection[1];rawConnection=rawConnection[2];connectionMap.has(fromID)||connectionMap.set(fromID,{parents:[],children:[]});var parentRelationship={ID:toID,relationship:rawConnection};connectionMap.get(fromID).parents.push(parentRelationship);connectionMap.has(toID)||
connectionMap.set(toID,{parents:[],children:[]});fromID={ID:fromID,relationship:rawConnection};connectionMap.get(toID).children.push(fromID)});return connectionMap},parseImages:function(){var images={},blobs={};if("Video"in fbxTree.Objects){var videoNodes=fbxTree.Objects.Video,nodeID;for(nodeID in videoNodes){var videoNode=videoNodes[nodeID],id=parseInt(nodeID);images[id]=videoNode.RelativeFilename||videoNode.Filename;if("Content"in videoNode){var base64Content="string"===typeof videoNode.Content&&
""!==videoNode.Content;if(videoNode.Content instanceof ArrayBuffer&&0<videoNode.Content.byteLength||base64Content)base64Content=this.parseImage(videoNodes[nodeID]),blobs[videoNode.RelativeFilename||videoNode.Filename]=base64Content}}}for(id in images)videoNodes=images[id],images[id]=void 0!==blobs[videoNodes]?blobs[videoNodes]:images[id].split("\\").pop();return images},parseImage:function(videoNode){var content=videoNode.Content;videoNode=videoNode.RelativeFilename||videoNode.Filename;videoNode=
videoNode.slice(videoNode.lastIndexOf(".")+1).toLowerCase();switch(videoNode){case "bmp":videoNode="image/bmp";break;case "jpg":case "jpeg":videoNode="image/jpeg";break;case "png":videoNode="image/png";break;case "tif":videoNode="image/tiff";break;case "tga":if("function"!==typeof THREE.TGALoader){console.warn("FBXLoader: THREE.TGALoader is required to load TGA textures");return}null===THREE.Loader.Handlers.get(".tga")&&THREE.Loader.Handlers.add(/\.tga$/i,new THREE.TGALoader);videoNode="image/tga";
break;default:console.warn('FBXLoader: Image type "'+videoNode+'" is not supported.');return}if("string"===typeof content)return"data:"+videoNode+";base64,"+content;content=new Uint8Array(content);return window.URL.createObjectURL(new Blob([content],{type:videoNode}))},parseTextures:function(images){var textureMap=new Map;if("Texture"in fbxTree.Objects){var textureNodes=fbxTree.Objects.Texture,nodeID;for(nodeID in textureNodes){var texture=this.parseTexture(textureNodes[nodeID],images);textureMap.set(parseInt(nodeID),
texture)}}return textureMap},parseTexture:function(textureNode,images){images=this.loadTexture(textureNode,images);images.ID=textureNode.id;images.name=textureNode.attrName;var wrapModeU=textureNode.WrapModeU,wrapModeV=textureNode.WrapModeV;wrapModeV=void 0!==wrapModeV?wrapModeV.value:0;images.wrapS=0===(void 0!==wrapModeU?wrapModeU.value:0)?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping;images.wrapT=0===wrapModeV?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping;"Scaling"in textureNode&&(textureNode=
textureNode.Scaling.value,images.repeat.x=textureNode[0],images.repeat.y=textureNode[1]);return images},loadTexture:function(textureNode,images){var currentPath=this.textureLoader.path,children=connections.get(textureNode.id).children;if(void 0!==children&&0<children.length&&void 0!==images[children[0].ID]){var fileName=images[children[0].ID];0!==fileName.indexOf("blob:")&&0!==fileName.indexOf("data:")||this.textureLoader.setPath(void 0)}textureNode=textureNode.FileName.slice(-3).toLowerCase();"tga"===
textureNode?(textureNode=THREE.Loader.Handlers.get(".tga"),null===textureNode?(console.warn("FBXLoader: TGALoader not found, creating empty placeholder texture for",fileName),fileName=new THREE.Texture):fileName=textureNode.load(fileName)):"psd"===textureNode?(console.warn("FBXLoader: PSD textures are not supported, creating empty placeholder texture for",fileName),fileName=new THREE.Texture):fileName=this.textureLoader.load(fileName);this.textureLoader.setPath(currentPath);return fileName},parseMaterials:function(textureMap){var materialMap=
new Map;if("Material"in fbxTree.Objects){var materialNodes=fbxTree.Objects.Material,nodeID;for(nodeID in materialNodes){var material=this.parseMaterial(materialNodes[nodeID],textureMap);null!==material&&materialMap.set(parseInt(nodeID),material)}}return materialMap},parseMaterial:function(materialNode,textureMap){var ID=materialNode.id,name=materialNode.attrName,type=materialNode.ShadingModel;"object"===typeof type&&(type=type.value);if(!connections.has(ID))return null;materialNode=this.parseParameters(materialNode,
textureMap,ID);switch(type.toLowerCase()){case "phong":type=new THREE.MeshPhongMaterial;break;case "lambert":type=new THREE.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',type),type=new THREE.MeshPhongMaterial({color:3342591})}type.setValues(materialNode);type.name=name;return type},parseParameters:function(materialNode,textureMap,ID){var parameters={};materialNode.BumpFactor&&(parameters.bumpScale=materialNode.BumpFactor.value);
materialNode.Diffuse?parameters.color=(new THREE.Color).fromArray(materialNode.Diffuse.value):materialNode.DiffuseColor&&"Color"===materialNode.DiffuseColor.type&&(parameters.color=(new THREE.Color).fromArray(materialNode.DiffuseColor.value));materialNode.DisplacementFactor&&(parameters.displacementScale=materialNode.DisplacementFactor.value);materialNode.Emissive?parameters.emissive=(new THREE.Color).fromArray(materialNode.Emissive.value):materialNode.EmissiveColor&&"Color"===materialNode.EmissiveColor.type&&
(parameters.emissive=(new THREE.Color).fromArray(materialNode.EmissiveColor.value));materialNode.EmissiveFactor&&(parameters.emissiveIntensity=parseFloat(materialNode.EmissiveFactor.value));materialNode.Opacity&&(parameters.opacity=parseFloat(materialNode.Opacity.value));1>parameters.opacity&&(parameters.transparent=!0);materialNode.ReflectionFactor&&(parameters.reflectivity=materialNode.ReflectionFactor.value);materialNode.Shininess&&(parameters.shininess=materialNode.Shininess.value);materialNode.Specular?
parameters.specular=(new THREE.Color).fromArray(materialNode.Specular.value):materialNode.SpecularColor&&"Color"===materialNode.SpecularColor.type&&(parameters.specular=(new THREE.Color).fromArray(materialNode.SpecularColor.value));var self=this;connections.get(ID).children.forEach(function(child){var type=child.relationship;switch(type){case "Bump":parameters.bumpMap=self.getTexture(textureMap,child.ID);break;case "DiffuseColor":parameters.map=self.getTexture(textureMap,child.ID);break;case "DisplacementColor":parameters.displacementMap=
self.getTexture(textureMap,child.ID);break;case "EmissiveColor":parameters.emissiveMap=self.getTexture(textureMap,child.ID);break;case "NormalMap":parameters.normalMap=self.getTexture(textureMap,child.ID);break;case "ReflectionColor":parameters.envMap=self.getTexture(textureMap,child.ID);parameters.envMap.mapping=THREE.EquirectangularReflectionMapping;break;case "SpecularColor":parameters.specularMap=self.getTexture(textureMap,child.ID);break;case "TransparentColor":parameters.alphaMap=self.getTexture(textureMap,
child.ID);parameters.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",type)}});return parameters},getTexture:function(textureMap,id){"LayeredTexture"in fbxTree.Objects&&id in fbxTree.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),id=connections.get(id).children[0].ID);return textureMap.get(id)},parseDeformers:function(){var skeletons={},morphTargets=
{};if("Deformer"in fbxTree.Objects){var DeformerNodes=fbxTree.Objects.Deformer,nodeID;for(nodeID in DeformerNodes){var deformerNode=DeformerNodes[nodeID],relationships=connections.get(parseInt(nodeID));"Skin"===deformerNode.attrType?(deformerNode=this.parseSkeleton(relationships,DeformerNodes),deformerNode.ID=nodeID,1<relationships.parents.length&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),deformerNode.geometryID=relationships.parents[0].ID,skeletons[nodeID]=
deformerNode):"BlendShape"===deformerNode.attrType&&(deformerNode={id:nodeID},deformerNode.rawTargets=this.parseMorphTargets(relationships,DeformerNodes),deformerNode.id=nodeID,1<relationships.parents.length&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),morphTargets[nodeID]=deformerNode)}}return{skeletons:skeletons,morphTargets:morphTargets}},parseSkeleton:function(relationships,deformerNodes){var rawBones=[];relationships.children.forEach(function(child){var boneNode=
deformerNodes[child.ID];"Cluster"===boneNode.attrType&&(child={ID:child.ID,indices:[],weights:[],transform:(new THREE.Matrix4).fromArray(boneNode.Transform.a),transformLink:(new THREE.Matrix4).fromArray(boneNode.TransformLink.a),linkMode:boneNode.Mode},"Indexes"in boneNode&&(child.indices=boneNode.Indexes.a,child.weights=boneNode.Weights.a),rawBones.push(child))});return{rawBones:rawBones,bones:[]}},parseMorphTargets:function(relationships,deformerNodes){for(var rawMorphTargets=[],i=0;i<relationships.children.length;i++){if(8===
i){console.warn("FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.");break}var child$jscomp$0=relationships.children[i],morphTargetNode=deformerNodes[child$jscomp$0.ID],rawMorphTarget={name:morphTargetNode.attrName,initialWeight:morphTargetNode.DeformPercent,id:morphTargetNode.id,fullWeights:morphTargetNode.FullWeights.a};if("BlendShapeChannel"!==morphTargetNode.attrType)return;connections.get(parseInt(child$jscomp$0.ID)).children.forEach(function(child){void 0===child.relationship&&
(rawMorphTarget.geoID=child.ID)});rawMorphTargets.push(rawMorphTarget)}return rawMorphTargets},parseScene:function(deformers,geometryMap,materialMap){sceneGraph=new THREE.Group;var modelMap=this.parseModels(deformers.skeletons,geometryMap,materialMap),modelNodes=fbxTree.Objects.Model,self=this;modelMap.forEach(function(model){self.setLookAtProperties(model,modelNodes[model.ID]);connections.get(model.ID).parents.forEach(function(connection){connection=modelMap.get(connection.ID);void 0!==connection&&
connection.add(model)});null===model.parent&&sceneGraph.add(model)});this.bindSkeleton(deformers.skeletons,geometryMap,modelMap);this.createAmbientLight();this.setupMorphMaterials();deformers=(new AnimationParser).parse();1===sceneGraph.children.length&&sceneGraph.children[0].isGroup&&(sceneGraph.children[0].animations=deformers,sceneGraph=sceneGraph.children[0]);sceneGraph.animations=deformers},parseModels:function(skeletons,geometryMap,materialMap){var modelMap=new Map,modelNodes=fbxTree.Objects.Model,
nodeID;for(nodeID in modelNodes){var id=parseInt(nodeID),node=modelNodes[nodeID],relationships=connections.get(id),model=this.buildSkeleton(relationships,skeletons,id,node.attrName);if(!model){switch(node.attrType){case "Camera":model=this.createCamera(relationships);break;case "Light":model=this.createLight(relationships);break;case "Mesh":model=this.createMesh(relationships,geometryMap,materialMap);break;case "NurbsCurve":model=this.createCurve(relationships,geometryMap);break;default:model=new THREE.Group}model.name=
THREE.PropertyBinding.sanitizeNodeName(node.attrName);model.ID=id}this.setModelTransforms(model,node);modelMap.set(id,model)}return modelMap},buildSkeleton:function(relationships,skeletons,id,name){var bone=null;relationships.parents.forEach(function(parent){for(var ID in skeletons){var skeleton=skeletons[ID];skeleton.rawBones.forEach(function(rawBone,i){if(rawBone.ID===parent.ID){var subBone=bone;bone=new THREE.Bone;bone.matrixWorld.copy(rawBone.transformLink);bone.name=THREE.PropertyBinding.sanitizeNodeName(name);
bone.ID=id;skeleton.bones[i]=bone;null!==subBone&&bone.add(subBone)}})}});return bone},createCamera:function(relationships){var cameraAttribute;relationships.children.forEach(function(child){child=fbxTree.Objects.NodeAttribute[child.ID];void 0!==child&&(cameraAttribute=child)});if(void 0===cameraAttribute)var model=new THREE.Object3D;else{model=0;void 0!==cameraAttribute.CameraProjectionType&&1===cameraAttribute.CameraProjectionType.value&&(model=1);var nearClippingPlane=1;void 0!==cameraAttribute.NearPlane&&
(nearClippingPlane=cameraAttribute.NearPlane.value/1E3);var farClippingPlane=1E3;void 0!==cameraAttribute.FarPlane&&(farClippingPlane=cameraAttribute.FarPlane.value/1E3);var width=window.innerWidth,height=window.innerHeight;void 0!==cameraAttribute.AspectWidth&&void 0!==cameraAttribute.AspectHeight&&(width=cameraAttribute.AspectWidth.value,height=cameraAttribute.AspectHeight.value);var aspect=width/height,fov=45;void 0!==cameraAttribute.FieldOfView&&(fov=cameraAttribute.FieldOfView.value);relationships=
cameraAttribute.FocalLength?cameraAttribute.FocalLength.value:null;switch(model){case 0:model=new THREE.PerspectiveCamera(fov,aspect,nearClippingPlane,farClippingPlane);null!==relationships&&model.setFocalLength(relationships);break;case 1:model=new THREE.OrthographicCamera(-width/2,width/2,height/2,-height/2,nearClippingPlane,farClippingPlane);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+model+"."),model=new THREE.Object3D}}return model},createLight:function(relationships){var lightAttribute;
relationships.children.forEach(function(child){child=fbxTree.Objects.NodeAttribute[child.ID];void 0!==child&&(lightAttribute=child)});if(void 0===lightAttribute)relationships=new THREE.Object3D;else{var type=void 0===lightAttribute.LightType?0:lightAttribute.LightType.value;relationships=16777215;void 0!==lightAttribute.Color&&(relationships=(new THREE.Color).fromArray(lightAttribute.Color.value));var intensity=void 0===lightAttribute.Intensity?1:lightAttribute.Intensity.value/100;void 0!==lightAttribute.CastLightOnObject&&
0===lightAttribute.CastLightOnObject.value&&(intensity=0);var distance=0;void 0!==lightAttribute.FarAttenuationEnd&&(distance=void 0!==lightAttribute.EnableFarAttenuation&&0===lightAttribute.EnableFarAttenuation.value?0:lightAttribute.FarAttenuationEnd.value);switch(type){case 0:relationships=new THREE.PointLight(relationships,intensity,distance,1);break;case 1:relationships=new THREE.DirectionalLight(relationships,intensity);break;case 2:type=Math.PI/3;void 0!==lightAttribute.InnerAngle&&(type=THREE.Math.degToRad(lightAttribute.InnerAngle.value));
var penumbra=0;void 0!==lightAttribute.OuterAngle&&(penumbra=THREE.Math.degToRad(lightAttribute.OuterAngle.value),penumbra=Math.max(penumbra,1));relationships=new THREE.SpotLight(relationships,intensity,distance,type,penumbra,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+lightAttribute.LightType.value+", defaulting to a THREE.PointLight."),relationships=new THREE.PointLight(relationships,intensity)}void 0!==lightAttribute.CastShadows&&1===lightAttribute.CastShadows.value&&(relationships.castShadow=
!0)}return relationships},createMesh:function(relationships,geometryMap,materialMap){var geometry=null,material$jscomp$0=null,materials=[];relationships.children.forEach(function(child){geometryMap.has(child.ID)&&(geometry=geometryMap.get(child.ID));materialMap.has(child.ID)&&materials.push(materialMap.get(child.ID))});1<materials.length?material$jscomp$0=materials:0<materials.length?material$jscomp$0=materials[0]:(material$jscomp$0=new THREE.MeshPhongMaterial({color:13421772}),materials.push(material$jscomp$0));
"color"in geometry.attributes&&materials.forEach(function(material){material.vertexColors=THREE.VertexColors});geometry.FBX_Deformer?(materials.forEach(function(material){material.skinning=!0}),relationships=new THREE.SkinnedMesh(geometry,material$jscomp$0)):relationships=new THREE.Mesh(geometry,material$jscomp$0);return relationships},createCurve:function(relationships,geometryMap){relationships=relationships.children.reduce(function(geo,child){geometryMap.has(child.ID)&&(geo=geometryMap.get(child.ID));
return geo},null);var material=new THREE.LineBasicMaterial({color:3342591,linewidth:1});return new THREE.Line(relationships,material)},setModelTransforms:function(model,modelNode){var transformData={};"RotationOrder"in modelNode&&(transformData.eulerOrder=parseInt(modelNode.RotationOrder.value));"Lcl_Translation"in modelNode&&(transformData.translation=modelNode.Lcl_Translation.value);"RotationOffset"in modelNode&&(transformData.rotationOffset=modelNode.RotationOffset.value);"Lcl_Rotation"in modelNode&&
(transformData.rotation=modelNode.Lcl_Rotation.value);"PreRotation"in modelNode&&(transformData.preRotation=modelNode.PreRotation.value);"PostRotation"in modelNode&&(transformData.postRotation=modelNode.PostRotation.value);"Lcl_Scaling"in modelNode&&(transformData.scale=modelNode.Lcl_Scaling.value);modelNode=generateTransform(transformData);model.applyMatrix(modelNode)},setLookAtProperties:function(model,modelNode){"LookAtProperty"in modelNode&&connections.get(model.ID).children.forEach(function(child){"LookAtProperty"===
child.relationship&&(child=fbxTree.Objects.Model[child.ID],"Lcl_Translation"in child&&(child=child.Lcl_Translation.value,void 0!==model.target?(model.target.position.fromArray(child),sceneGraph.add(model.target)):model.lookAt((new THREE.Vector3).fromArray(child))))})},bindSkeleton:function(skeletons,geometryMap,modelMap){var bindMatrices=this.parsePoseNodes(),ID;for(ID in skeletons){var skeleton=skeletons[ID];connections.get(parseInt(skeleton.ID)).parents.forEach(function(parent){geometryMap.has(parent.ID)&&
connections.get(parent.ID).parents.forEach(function(geoConnParent){modelMap.has(geoConnParent.ID)&&modelMap.get(geoConnParent.ID).bind(new THREE.Skeleton(skeleton.bones),bindMatrices[geoConnParent.ID])})})}},parsePoseNodes:function(){var bindMatrices={};if("Pose"in fbxTree.Objects){var BindPoseNode=fbxTree.Objects.Pose,nodeID;for(nodeID in BindPoseNode)if("BindPose"===BindPoseNode[nodeID].attrType){var poseNodes=BindPoseNode[nodeID].PoseNode;Array.isArray(poseNodes)?poseNodes.forEach(function(poseNode){bindMatrices[poseNode.Node]=
(new THREE.Matrix4).fromArray(poseNode.Matrix.a)}):bindMatrices[poseNodes.Node]=(new THREE.Matrix4).fromArray(poseNodes.Matrix.a)}}return bindMatrices},createAmbientLight:function(){if("GlobalSettings"in fbxTree&&"AmbientColor"in fbxTree.GlobalSettings){var ambientColor=fbxTree.GlobalSettings.AmbientColor.value,r=ambientColor[0],g=ambientColor[1];ambientColor=ambientColor[2];if(0!==r||0!==g||0!==ambientColor)r=new THREE.Color(r,g,ambientColor),sceneGraph.add(new THREE.AmbientLight(r,1))}},setupMorphMaterials:function(){sceneGraph.traverse(function(child$jscomp$0){if(child$jscomp$0.isMesh&&
(child$jscomp$0.geometry.morphAttributes.position||child$jscomp$0.geometry.morphAttributes.normal)){var uuid=child$jscomp$0.uuid,matUuid=child$jscomp$0.material.uuid,sharedMat=!1;sceneGraph.traverse(function(child){child.isMesh&&child.material.uuid===matUuid&&child.uuid!==uuid&&(sharedMat=!0)});!0===sharedMat&&(child$jscomp$0.material=child$jscomp$0.material.clone());child$jscomp$0.material.morphTargets=!0}})}};GeometryParser.prototype={constructor:GeometryParser,parse:function(deformers){var geometryMap=
new Map;if("Geometry"in fbxTree.Objects){var geoNodes=fbxTree.Objects.Geometry,nodeID;for(nodeID in geoNodes){var relationships=connections.get(parseInt(nodeID));relationships=this.parseGeometry(relationships,geoNodes[nodeID],deformers);geometryMap.set(parseInt(nodeID),relationships)}}return geometryMap},parseGeometry:function(relationships,geoNode,deformers){switch(geoNode.attrType){case "Mesh":return this.parseMeshGeometry(relationships,geoNode,deformers);case "NurbsCurve":return this.parseNurbsGeometry(geoNode)}},
parseMeshGeometry:function(relationships,geoNode,deformers){var skeletons=deformers.skeletons,morphTargets=deformers.morphTargets,modelNodes=relationships.parents.map(function(parent){return fbxTree.Objects.Model[parent.ID]});if(0!==modelNodes.length){deformers=relationships.children.reduce(function(skeleton,child){void 0!==skeletons[child.ID]&&(skeleton=skeletons[child.ID]);return skeleton},null);relationships=relationships.children.reduce(function(morphTarget,child){void 0!==morphTargets[child.ID]&&
(morphTarget=morphTargets[child.ID]);return morphTarget},null);modelNodes=modelNodes[0];var transformData={};"RotationOrder"in modelNodes&&(transformData.eulerOrder=modelNodes.RotationOrder.value);"GeometricTranslation"in modelNodes&&(transformData.translation=modelNodes.GeometricTranslation.value);"GeometricRotation"in modelNodes&&(transformData.rotation=modelNodes.GeometricRotation.value);"GeometricScaling"in modelNodes&&(transformData.scale=modelNodes.GeometricScaling.value);modelNodes=generateTransform(transformData);
return this.genGeometry(geoNode,deformers,relationships,modelNodes)}},genGeometry:function(geoNode,skeleton,morphTarget,preTransform){var geo=new THREE.BufferGeometry;geoNode.attrName&&(geo.name=geoNode.attrName);var geoInfo=this.parseGeoNode(geoNode,skeleton),buffers=this.genBuffers(geoInfo),positionAttribute=new THREE.Float32BufferAttribute(buffers.vertex,3);preTransform.applyToBufferAttribute(positionAttribute);geo.addAttribute("position",positionAttribute);0<buffers.colors.length&&geo.addAttribute("color",
new THREE.Float32BufferAttribute(buffers.colors,3));skeleton&&(geo.addAttribute("skinIndex",new THREE.Uint16BufferAttribute(buffers.weightsIndices,4)),geo.addAttribute("skinWeight",new THREE.Float32BufferAttribute(buffers.vertexWeights,4)),geo.FBX_Deformer=skeleton);0<buffers.normal.length&&(skeleton=new THREE.Float32BufferAttribute(buffers.normal,3),(new THREE.Matrix3).getNormalMatrix(preTransform).applyToBufferAttribute(skeleton),geo.addAttribute("normal",skeleton));buffers.uvs.forEach(function(uvBuffer,
i){uvBuffer="uv"+(i+1).toString();0===i&&(uvBuffer="uv");geo.addAttribute(uvBuffer,new THREE.Float32BufferAttribute(buffers.uvs[i],2))});if(geoInfo.material&&"AllSame"!==geoInfo.material.mappingType){var prevMaterialIndex=buffers.materialIndex[0],startIndex=0;buffers.materialIndex.forEach(function(currentIndex,i){currentIndex!==prevMaterialIndex&&(geo.addGroup(startIndex,i-startIndex,prevMaterialIndex),prevMaterialIndex=currentIndex,startIndex=i)});0<geo.groups.length&&(geoInfo=geo.groups[geo.groups.length-
1],geoInfo=geoInfo.start+geoInfo.count,geoInfo!==buffers.materialIndex.length&&geo.addGroup(geoInfo,buffers.materialIndex.length-geoInfo,prevMaterialIndex));0===geo.groups.length&&geo.addGroup(0,buffers.materialIndex.length,buffers.materialIndex[0])}this.addMorphTargets(geo,geoNode,morphTarget,preTransform);return geo},parseGeoNode:function(geoNode,skeleton){var geoInfo={};geoInfo.vertexPositions=void 0!==geoNode.Vertices?geoNode.Vertices.a:[];geoInfo.vertexIndices=void 0!==geoNode.PolygonVertexIndex?
geoNode.PolygonVertexIndex.a:[];geoNode.LayerElementColor&&(geoInfo.color=this.parseVertexColors(geoNode.LayerElementColor[0]));geoNode.LayerElementMaterial&&(geoInfo.material=this.parseMaterialIndices(geoNode.LayerElementMaterial[0]));geoNode.LayerElementNormal&&(geoInfo.normal=this.parseNormals(geoNode.LayerElementNormal[0]));if(geoNode.LayerElementUV){geoInfo.uv=[];for(var i$jscomp$0=0;geoNode.LayerElementUV[i$jscomp$0];)geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i$jscomp$0])),i$jscomp$0++}geoInfo.weightTable=
{};null!==skeleton&&(geoInfo.skeleton=skeleton,skeleton.rawBones.forEach(function(rawBone,i){rawBone.indices.forEach(function(index,j){void 0===geoInfo.weightTable[index]&&(geoInfo.weightTable[index]=[]);geoInfo.weightTable[index].push({id:i,weight:rawBone.weights[j]})})}));return geoInfo},genBuffers:function(geoInfo){var buffers={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},polygonIndex=0,faceLength=0,displayedWeightsWarning=!1,facePositionIndexes=[],
faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[],self=this;geoInfo.vertexIndices.forEach(function(vertexIndex,polygonVertexIndex){var endOfFace=!1;0>vertexIndex&&(vertexIndex^=-1,endOfFace=!0);var weightIndices=[],weights=[];facePositionIndexes.push(3*vertexIndex,3*vertexIndex+1,3*vertexIndex+2);if(geoInfo.color){var data=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.color);faceColors.push(data[0],data[1],data[2])}if(geoInfo.skeleton){void 0!==geoInfo.weightTable[vertexIndex]&&
geoInfo.weightTable[vertexIndex].forEach(function(wt){weights.push(wt.weight);weightIndices.push(wt.id)});if(4<weights.length){displayedWeightsWarning||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),displayedWeightsWarning=!0);var wIndex=[0,0,0,0],Weight=[0,0,0,0];weights.forEach(function(weight,weightIndex){var currentWeight=weight,currentIndex=weightIndices[weightIndex];Weight.forEach(function(comparedWeight,comparedWeightIndex,
comparedWeightArray){currentWeight>comparedWeight&&(comparedWeightArray[comparedWeightIndex]=currentWeight,currentWeight=comparedWeight,comparedWeight=wIndex[comparedWeightIndex],wIndex[comparedWeightIndex]=currentIndex,currentIndex=comparedWeight)})});weightIndices=wIndex;weights=Weight}for(;4>weights.length;)weights.push(0),weightIndices.push(0);for(data=0;4>data;++data)faceWeights.push(weights[data]),faceWeightIndices.push(weightIndices[data])}geoInfo.normal&&(data=getData(polygonVertexIndex,polygonIndex,
vertexIndex,geoInfo.normal),faceNormals.push(data[0],data[1],data[2]));if(geoInfo.material&&"AllSame"!==geoInfo.material.mappingType)var materialIndex=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.material)[0];geoInfo.uv&&geoInfo.uv.forEach(function(uv,i){uv=getData(polygonVertexIndex,polygonIndex,vertexIndex,uv);void 0===faceUVs[i]&&(faceUVs[i]=[]);faceUVs[i].push(uv[0]);faceUVs[i].push(uv[1])});faceLength++;endOfFace&&(self.genFace(buffers,geoInfo,facePositionIndexes,materialIndex,
faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength),polygonIndex++,faceLength=0,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[])});return buffers},genFace:function(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength){for(var i=2;i<faceLength;i++)buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]),
buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)+1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)+2]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i+1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*
i+2]]),geoInfo.skeleton&&(buffers.vertexWeights.push(faceWeights[0]),buffers.vertexWeights.push(faceWeights[1]),buffers.vertexWeights.push(faceWeights[2]),buffers.vertexWeights.push(faceWeights[3]),buffers.vertexWeights.push(faceWeights[4*(i-1)]),buffers.vertexWeights.push(faceWeights[4*(i-1)+1]),buffers.vertexWeights.push(faceWeights[4*(i-1)+2]),buffers.vertexWeights.push(faceWeights[4*(i-1)+3]),buffers.vertexWeights.push(faceWeights[4*i]),buffers.vertexWeights.push(faceWeights[4*i+1]),buffers.vertexWeights.push(faceWeights[4*
i+2]),buffers.vertexWeights.push(faceWeights[4*i+3]),buffers.weightsIndices.push(faceWeightIndices[0]),buffers.weightsIndices.push(faceWeightIndices[1]),buffers.weightsIndices.push(faceWeightIndices[2]),buffers.weightsIndices.push(faceWeightIndices[3]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+1]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+2]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+3]),buffers.weightsIndices.push(faceWeightIndices[4*
i]),buffers.weightsIndices.push(faceWeightIndices[4*i+1]),buffers.weightsIndices.push(faceWeightIndices[4*i+2]),buffers.weightsIndices.push(faceWeightIndices[4*i+3])),geoInfo.color&&(buffers.colors.push(faceColors[0]),buffers.colors.push(faceColors[1]),buffers.colors.push(faceColors[2]),buffers.colors.push(faceColors[3*(i-1)]),buffers.colors.push(faceColors[3*(i-1)+1]),buffers.colors.push(faceColors[3*(i-1)+2]),buffers.colors.push(faceColors[3*i]),buffers.colors.push(faceColors[3*i+1]),buffers.colors.push(faceColors[3*
i+2])),geoInfo.material&&"AllSame"!==geoInfo.material.mappingType&&(buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex)),geoInfo.normal&&(buffers.normal.push(faceNormals[0]),buffers.normal.push(faceNormals[1]),buffers.normal.push(faceNormals[2]),buffers.normal.push(faceNormals[3*(i-1)]),buffers.normal.push(faceNormals[3*(i-1)+1]),buffers.normal.push(faceNormals[3*(i-1)+2]),buffers.normal.push(faceNormals[3*i]),buffers.normal.push(faceNormals[3*
i+1]),buffers.normal.push(faceNormals[3*i+2])),geoInfo.uv&&geoInfo.uv.forEach(function(uv,j){void 0===buffers.uvs[j]&&(buffers.uvs[j]=[]);buffers.uvs[j].push(faceUVs[j][0]);buffers.uvs[j].push(faceUVs[j][1]);buffers.uvs[j].push(faceUVs[j][2*(i-1)]);buffers.uvs[j].push(faceUVs[j][2*(i-1)+1]);buffers.uvs[j].push(faceUVs[j][2*i]);buffers.uvs[j].push(faceUVs[j][2*i+1])})},addMorphTargets:function(parentGeo,parentGeoNode,morphTarget,preTransform){if(null!==morphTarget){parentGeo.morphAttributes.position=
[];parentGeo.morphAttributes.normal=[];var self=this;morphTarget.rawTargets.forEach(function(rawTarget){rawTarget=fbxTree.Objects.Geometry[rawTarget.geoID];void 0!==rawTarget&&self.genMorphGeometry(parentGeo,parentGeoNode,rawTarget,preTransform)})}},genMorphGeometry:function(parentGeo,parentGeoNode,morphGeoNode,preTransform){var morphGeo=new THREE.BufferGeometry;morphGeoNode.attrName&&(morphGeo.name=morphGeoNode.attrName);morphGeo=void 0!==parentGeoNode.PolygonVertexIndex?parentGeoNode.PolygonVertexIndex.a:
[];parentGeoNode=void 0!==parentGeoNode.Vertices?parentGeoNode.Vertices.a.slice():[];for(var morphPositions=void 0!==morphGeoNode.Vertices?morphGeoNode.Vertices.a:[],indices=void 0!==morphGeoNode.Indexes?morphGeoNode.Indexes.a:[],i=0;i<indices.length;i++){var morphIndex=3*indices[i];parentGeoNode[morphIndex]+=morphPositions[3*i];parentGeoNode[morphIndex+1]+=morphPositions[3*i+1];parentGeoNode[morphIndex+2]+=morphPositions[3*i+2]}morphGeo=this.genBuffers({vertexIndices:morphGeo,vertexPositions:parentGeoNode});
morphGeo=new THREE.Float32BufferAttribute(morphGeo.vertex,3);morphGeo.name=morphGeoNode.attrName;preTransform.applyToBufferAttribute(morphGeo);parentGeo.morphAttributes.position.push(morphGeo)},parseNormals:function(NormalNode){var mappingType=NormalNode.MappingInformationType,referenceType=NormalNode.ReferenceInformationType,buffer=NormalNode.Normals.a,indexBuffer=[];"IndexToDirect"===referenceType&&("NormalIndex"in NormalNode?indexBuffer=NormalNode.NormalIndex.a:"NormalsIndex"in NormalNode&&(indexBuffer=
NormalNode.NormalsIndex.a));return{dataSize:3,buffer:buffer,indices:indexBuffer,mappingType:mappingType,referenceType:referenceType}},parseUVs:function(UVNode){var mappingType=UVNode.MappingInformationType,referenceType=UVNode.ReferenceInformationType,buffer=UVNode.UV.a,indexBuffer=[];"IndexToDirect"===referenceType&&(indexBuffer=UVNode.UVIndex.a);return{dataSize:2,buffer:buffer,indices:indexBuffer,mappingType:mappingType,referenceType:referenceType}},parseVertexColors:function(ColorNode){var mappingType=
ColorNode.MappingInformationType,referenceType=ColorNode.ReferenceInformationType,buffer=ColorNode.Colors.a,indexBuffer=[];"IndexToDirect"===referenceType&&(indexBuffer=ColorNode.ColorIndex.a);return{dataSize:4,buffer:buffer,indices:indexBuffer,mappingType:mappingType,referenceType:referenceType}},parseMaterialIndices:function(MaterialNode){var mappingType=MaterialNode.MappingInformationType,referenceType=MaterialNode.ReferenceInformationType;if("NoMappingInformation"===mappingType)return{dataSize:1,
buffer:[0],indices:[0],mappingType:"AllSame",referenceType:referenceType};MaterialNode=MaterialNode.Materials.a;for(var materialIndices=[],i=0;i<MaterialNode.length;++i)materialIndices.push(i);return{dataSize:1,buffer:MaterialNode,indices:materialIndices,mappingType:mappingType,referenceType:referenceType}},parseNurbsGeometry:function(geoNode){if(void 0===THREE.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),
new THREE.BufferGeometry;var order=parseInt(geoNode.Order);if(isNaN(order))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",geoNode.Order,geoNode.id),new THREE.BufferGeometry;--order;for(var knots=geoNode.KnotVector.a,controlPoints=[],pointsValues=geoNode.Points.a,i$jscomp$0=0,l=pointsValues.length;i$jscomp$0<l;i$jscomp$0+=4)controlPoints.push((new THREE.Vector4).fromArray(pointsValues,i$jscomp$0));if("Closed"===geoNode.Form)controlPoints.push(controlPoints[0]);else if("Periodic"===
geoNode.Form){var startKnot=order;var endKnot=knots.length-1-startKnot;for(i$jscomp$0=0;i$jscomp$0<order;++i$jscomp$0)controlPoints.push(controlPoints[i$jscomp$0])}geoNode=(new THREE.NURBSCurve(order,knots,controlPoints,startKnot,endKnot)).getPoints(7*controlPoints.length);var positions=new Float32Array(3*geoNode.length);geoNode.forEach(function(vertex,i){vertex.toArray(positions,3*i)});geoNode=new THREE.BufferGeometry;geoNode.addAttribute("position",new THREE.BufferAttribute(positions,3));return geoNode}};
AnimationParser.prototype={constructor:AnimationParser,parse:function(){var animationClips=[],rawClips=this.parseClips();if(void 0===rawClips)return animationClips;for(var key in rawClips){var clip=this.addClip(rawClips[key]);animationClips.push(clip)}return animationClips},parseClips:function(){if(void 0!==fbxTree.Objects.AnimationCurve){var curveNodesMap=this.parseAnimationCurveNodes();this.parseAnimationCurves(curveNodesMap);curveNodesMap=this.parseAnimationLayers(curveNodesMap);return this.parseAnimStacks(curveNodesMap)}},
parseAnimationCurveNodes:function(){var rawCurveNodes=fbxTree.Objects.AnimationCurveNode,curveNodesMap=new Map,nodeID;for(nodeID in rawCurveNodes){var rawCurveNode=rawCurveNodes[nodeID];null!==rawCurveNode.attrName.match(/S|R|T|DeformPercent/)&&(rawCurveNode={id:rawCurveNode.id,attr:rawCurveNode.attrName,curves:{}},curveNodesMap.set(rawCurveNode.id,rawCurveNode))}return curveNodesMap},parseAnimationCurves:function(curveNodesMap){var rawCurves=fbxTree.Objects.AnimationCurve,nodeID;for(nodeID in rawCurves){var animationCurve=
{id:rawCurves[nodeID].id,times:rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),values:rawCurves[nodeID].KeyValueFloat.a},relationships=connections.get(animationCurve.id);if(void 0!==relationships){var animationCurveID=relationships.parents[0].ID;relationships=relationships.parents[0].relationship;relationships.match(/X/)?curveNodesMap.get(animationCurveID).curves.x=animationCurve:relationships.match(/Y/)?curveNodesMap.get(animationCurveID).curves.y=animationCurve:relationships.match(/Z/)?
curveNodesMap.get(animationCurveID).curves.z=animationCurve:relationships.match(/d|DeformPercent/)&&curveNodesMap.has(animationCurveID)&&(curveNodesMap.get(animationCurveID).curves.morph=animationCurve)}}},parseAnimationLayers:function(curveNodesMap){var rawLayers=fbxTree.Objects.AnimationLayer,layersMap=new Map,nodeID;for(nodeID in rawLayers){var layerCurveNodes=[];rawLayers=connections.get(parseInt(nodeID));if(void 0!==rawLayers){var self=this;rawLayers.children.forEach(function(child,i){if(curveNodesMap.has(child.ID)){var curveNode=
curveNodesMap.get(child.ID);if(void 0!==curveNode.curves.x||void 0!==curveNode.curves.y||void 0!==curveNode.curves.z){if(void 0===layerCurveNodes[i]){connections.get(child.ID).parents.forEach(function(parent){void 0!==parent.relationship&&(modelID=parent.ID)});child=fbxTree.Objects.Model[modelID.toString()];var node={modelName:THREE.PropertyBinding.sanitizeNodeName(child.attrName),initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1],transform:self.getModelAnimTransform(child)};"PreRotation"in
child&&(node.preRotations=child.PreRotation.value);"PostRotation"in child&&(node.postRotations=child.PostRotation.value);layerCurveNodes[i]=node}layerCurveNodes[i][curveNode.attr]=curveNode}else if(void 0!==curveNode.curves.morph){if(void 0===layerCurveNodes[i]){var deformerID;connections.get(child.ID).parents.forEach(function(parent){void 0!==parent.relationship&&(deformerID=parent.ID)});child=connections.get(deformerID).parents[0].ID;child=connections.get(child).parents[0].ID;var modelID=connections.get(child).parents[0].ID;
child=fbxTree.Objects.Model[modelID];node={modelName:THREE.PropertyBinding.sanitizeNodeName(child.attrName),morphName:fbxTree.Objects.Deformer[deformerID].attrName};layerCurveNodes[i]=node}layerCurveNodes[i][curveNode.attr]=curveNode}}});layersMap.set(parseInt(nodeID),layerCurveNodes)}}return layersMap},getModelAnimTransform:function(modelNode){var transformData={};"RotationOrder"in modelNode&&(transformData.eulerOrder=parseInt(modelNode.RotationOrder.value));"Lcl_Translation"in modelNode&&(transformData.translation=
modelNode.Lcl_Translation.value);"RotationOffset"in modelNode&&(transformData.rotationOffset=modelNode.RotationOffset.value);"Lcl_Rotation"in modelNode&&(transformData.rotation=modelNode.Lcl_Rotation.value);"PreRotation"in modelNode&&(transformData.preRotation=modelNode.PreRotation.value);"PostRotation"in modelNode&&(transformData.postRotation=modelNode.PostRotation.value);"Lcl_Scaling"in modelNode&&(transformData.scale=modelNode.Lcl_Scaling.value);return generateTransform(transformData)},parseAnimStacks:function(layersMap){var rawStacks=
fbxTree.Objects.AnimationStack,rawClips={},nodeID;for(nodeID in rawStacks){var children=connections.get(parseInt(nodeID)).children;1<children.length&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");children=layersMap.get(children[0].ID);rawClips[nodeID]={name:rawStacks[nodeID].attrName,layer:children}}return rawClips},addClip:function(rawClip){var tracks=[],self=this;rawClip.layer.forEach(function(rawTracks){tracks=
tracks.concat(self.generateTracks(rawTracks))});return new THREE.AnimationClip(rawClip.name,-1,tracks)},generateTracks:function(rawTracks){var tracks=[],initialPosition=new THREE.Vector3,initialRotation=new THREE.Quaternion,initialScale=new THREE.Vector3;rawTracks.transform&&rawTracks.transform.decompose(initialPosition,initialRotation,initialScale);initialPosition=initialPosition.toArray();initialRotation=(new THREE.Euler).setFromQuaternion(initialRotation).toArray();initialScale=initialScale.toArray();
void 0!==rawTracks.T&&0<Object.keys(rawTracks.T.curves).length&&(initialPosition=this.generateVectorTrack(rawTracks.modelName,rawTracks.T.curves,initialPosition,"position"),void 0!==initialPosition&&tracks.push(initialPosition));void 0!==rawTracks.R&&0<Object.keys(rawTracks.R.curves).length&&(initialRotation=this.generateRotationTrack(rawTracks.modelName,rawTracks.R.curves,initialRotation,rawTracks.preRotations,rawTracks.postRotations),void 0!==initialRotation&&tracks.push(initialRotation));void 0!==
rawTracks.S&&0<Object.keys(rawTracks.S.curves).length&&(initialScale=this.generateVectorTrack(rawTracks.modelName,rawTracks.S.curves,initialScale,"scale"),void 0!==initialScale&&tracks.push(initialScale));void 0!==rawTracks.DeformPercent&&(rawTracks=this.generateMorphTrack(rawTracks),void 0!==rawTracks&&tracks.push(rawTracks));return tracks},generateVectorTrack:function(modelName,curves,initialValue,type){var times=this.getTimesForAllAxes(curves);curves=this.getKeyframeTrackValues(times,curves,initialValue);
return new THREE.VectorKeyframeTrack(modelName+"."+type,times,curves)},generateRotationTrack:function(modelName,curves,initialValue,preRotations,postRotations){void 0!==curves.x&&(this.interpolateRotations(curves.x),curves.x.values=curves.x.values.map(THREE.Math.degToRad));void 0!==curves.y&&(this.interpolateRotations(curves.y),curves.y.values=curves.y.values.map(THREE.Math.degToRad));void 0!==curves.z&&(this.interpolateRotations(curves.z),curves.z.values=curves.z.values.map(THREE.Math.degToRad));
var times=this.getTimesForAllAxes(curves);curves=this.getKeyframeTrackValues(times,curves,initialValue);void 0!==preRotations&&(preRotations=preRotations.map(THREE.Math.degToRad),preRotations.push("ZYX"),preRotations=(new THREE.Euler).fromArray(preRotations),preRotations=(new THREE.Quaternion).setFromEuler(preRotations));void 0!==postRotations&&(postRotations=postRotations.map(THREE.Math.degToRad),postRotations.push("ZYX"),postRotations=(new THREE.Euler).fromArray(postRotations),postRotations=(new THREE.Quaternion).setFromEuler(postRotations).inverse());
initialValue=new THREE.Quaternion;for(var euler=new THREE.Euler,quaternionValues=[],i=0;i<curves.length;i+=3)euler.set(curves[i],curves[i+1],curves[i+2],"ZYX"),initialValue.setFromEuler(euler),void 0!==preRotations&&initialValue.premultiply(preRotations),void 0!==postRotations&&initialValue.multiply(postRotations),initialValue.toArray(quaternionValues,i/3*4);return new THREE.QuaternionKeyframeTrack(modelName+".quaternion",times,quaternionValues)},generateMorphTrack:function(rawTracks){var curves=
rawTracks.DeformPercent.curves.morph,values=curves.values.map(function(val){return val/100}),morphNum=sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];return new THREE.NumberKeyframeTrack(rawTracks.modelName+".morphTargetInfluences["+morphNum+"]",curves.times,values)},getTimesForAllAxes:function(curves){var times=[];void 0!==curves.x&&(times=times.concat(curves.x.times));void 0!==curves.y&&(times=times.concat(curves.y.times));void 0!==curves.z&&(times=times.concat(curves.z.times));
return times=times.sort(function(a,b){return a-b}).filter(function(elem,index,array){return array.indexOf(elem)==index})},getKeyframeTrackValues:function(times,curves,initialValue){var values=[],xIndex=-1,yIndex=-1,zIndex=-1;times.forEach(function(time){curves.x&&(xIndex=curves.x.times.indexOf(time));curves.y&&(yIndex=curves.y.times.indexOf(time));curves.z&&(zIndex=curves.z.times.indexOf(time));-1!==xIndex?(time=curves.x.values[xIndex],values.push(time),initialValue[0]=time):values.push(initialValue[0]);
-1!==yIndex?(time=curves.y.values[yIndex],values.push(time),initialValue[1]=time):values.push(initialValue[1]);-1!==zIndex?(time=curves.z.values[zIndex],values.push(time),initialValue[2]=time):values.push(initialValue[2])});return values},interpolateRotations:function(curve){for(var i=1;i<curve.values.length;i++){var initialValue=curve.values[i-1],valuesSpan=curve.values[i]-initialValue,absoluteSpan=Math.abs(valuesSpan);if(180<=absoluteSpan){absoluteSpan/=180;valuesSpan/=absoluteSpan;initialValue+=
valuesSpan;var initialTime=curve.times[i-1];absoluteSpan=(curve.times[i]-initialTime)/absoluteSpan;initialTime+=absoluteSpan;for(var interpolatedTimes=[],interpolatedValues=[];initialTime<curve.times[i];)interpolatedTimes.push(initialTime),initialTime+=absoluteSpan,interpolatedValues.push(initialValue),initialValue+=valuesSpan;curve.times=inject(curve.times,i,interpolatedTimes);curve.values=inject(curve.values,i,interpolatedValues)}}}};TextParser.prototype={constructor:TextParser,getPrevNode:function(){return this.nodeStack[this.currentIndent-
2]},getCurrentNode:function(){return this.nodeStack[this.currentIndent-1]},getCurrentProp:function(){return this.currentProp},pushStack:function(node){this.nodeStack.push(node);this.currentIndent+=1},popStack:function(){this.nodeStack.pop();--this.currentIndent},setCurrentProp:function(val,name){this.currentProp=val;this.currentPropName=name},parse:function(text){this.currentIndent=0;console.log("FBXTree: ",FBXTree);this.allNodes=new FBXTree;this.nodeStack=[];this.currentProp=[];this.currentPropName=
"";var self=this,split=text.split(/[\r\n]+/);split.forEach(function(line,i){var matchComment=line.match(/^[\s\t]*;/),matchEmpty=line.match(/^[\s\t]*$/);if(!matchComment&&!matchEmpty){matchComment=line.match("^\\t{"+self.currentIndent+"}(\\w+):(.*){","");matchEmpty=line.match("^\\t{"+self.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)");var matchEnd=line.match("^\\t{"+(self.currentIndent-1)+"}}");matchComment?self.parseNodeBegin(line,matchComment):matchEmpty?self.parseNodeProperty(line,matchEmpty,split[++i]):
matchEnd?self.popStack():line.match(/^[^\s\t}]/)&&self.parseNodePropertyContinued(line)}});return this.allNodes},parseNodeBegin:function(line,property){line=property[1].trim().replace(/^"/,"").replace(/"$/,"");var nodeAttrs=property[2].split(",").map(function(attr){return attr.trim().replace(/^"/,"").replace(/"$/,"")});property={name:line};nodeAttrs=this.parseNodeAttr(nodeAttrs);var currentNode=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(line,property):line in currentNode?("PoseNode"===
line?currentNode.PoseNode.push(property):void 0!==currentNode[line].id&&(currentNode[line]={},currentNode[line][currentNode[line].id]=currentNode[line]),""!==nodeAttrs.id&&(currentNode[line][nodeAttrs.id]=property)):"number"===typeof nodeAttrs.id?(currentNode[line]={},currentNode[line][nodeAttrs.id]=property):"Properties70"!==line&&(currentNode[line]="PoseNode"===line?[property]:property);"number"===typeof nodeAttrs.id&&(property.id=nodeAttrs.id);""!==nodeAttrs.name&&(property.attrName=nodeAttrs.name);
""!==nodeAttrs.type&&(property.attrType=nodeAttrs.type);this.pushStack(property)},parseNodeAttr:function(attrs){var id=attrs[0];""!==attrs[0]&&(id=parseInt(attrs[0]),isNaN(id)&&(id=attrs[0]));var name="",type="";1<attrs.length&&(name=attrs[1].replace(/^(\w+)::/,""),type=attrs[2]);return{id:id,name:name,type:type}},parseNodeProperty:function(line,property,contentLine){var propName=property[1].replace(/^"/,"").replace(/"$/,"").trim();property=property[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===
propName&&","===property&&(property=contentLine.replace(/"/g,"").replace(/,$/,"").trim());contentLine=this.getCurrentNode();if("Properties70"===contentLine.name)this.parseNodeSpecialProperty(line,propName,property);else{if("C"===propName){propName=property.split(",").slice(1);line=parseInt(propName[0]);var to=parseInt(propName[1]),rest=property.split(",").slice(3);rest=rest.map(function(elem){return elem.trim().replace(/^"/,"")});propName="connections";property=[line,to];append(property,rest);void 0===
contentLine[propName]&&(contentLine[propName]=[])}"Node"===propName&&(contentLine.id=property);propName in contentLine&&Array.isArray(contentLine[propName])?contentLine[propName].push(property):"a"!==propName?contentLine[propName]=property:contentLine.a=property;this.setCurrentProp(contentLine,propName);"a"===propName&&","!==property.slice(-1)&&(contentLine.a=parseNumberArray(property))}},parseNodePropertyContinued:function(line){var currentNode=this.getCurrentNode();currentNode.a+=line;","!==line.slice(-1)&&
(currentNode.a=parseNumberArray(currentNode.a))},parseNodeSpecialProperty:function(line,propName,propValue){var props=propValue.split('",').map(function(prop){return prop.trim().replace(/^"/,"").replace(/\s/,"_")});line=props[0];propName=props[1];propValue=props[2];var innerPropFlag=props[3];props=props[4];switch(propName){case "int":case "enum":case "bool":case "ULongLong":case "double":case "Number":case "FieldOfView":props=parseFloat(props);break;case "Color":case "ColorRGB":case "Vector3D":case "Lcl_Translation":case "Lcl_Rotation":case "Lcl_Scaling":props=
parseNumberArray(props)}this.getPrevNode()[line]={type:propName,type2:propValue,flag:innerPropFlag,value:props};this.setCurrentProp(this.getPrevNode(),line)}};BinaryParser.prototype={constructor:BinaryParser,parse:function(buffer){buffer=new BinaryReader(buffer);buffer.skip(23);var version=buffer.getUint32();console.log("THREE.FBXLoader: FBX binary version: "+version);for(var allNodes=new FBXTree;!this.endOfContent(buffer);){var node=this.parseNode(buffer,version);null!==node&&allNodes.add(node.name,
node)}return allNodes},endOfContent:function(reader){return 0===reader.size()%16?(reader.getOffset()+160+16&-16)>=reader.size():reader.getOffset()+160+16>=reader.size()},parseNode:function(reader,version){var node={},endOffset=7500<=version?reader.getUint64():reader.getUint32(),numProperties=7500<=version?reader.getUint64():reader.getUint32();7500<=version?reader.getUint64():reader.getUint32();var nameLen=reader.getUint8();nameLen=reader.getString(nameLen);if(0===endOffset)return null;for(var propertyList=
[],i=0;i<numProperties;i++)propertyList.push(this.parseProperty(reader));i=0<propertyList.length?propertyList[0]:"";var attrName=1<propertyList.length?propertyList[1]:"",attrType=2<propertyList.length?propertyList[2]:"";for(node.singleProperty=1===numProperties&&reader.getOffset()===endOffset?!0:!1;endOffset>reader.getOffset();)numProperties=this.parseNode(reader,version),null!==numProperties&&this.parseSubNode(nameLen,node,numProperties);node.propertyList=propertyList;"number"===typeof i&&(node.id=
i);""!==attrName&&(node.attrName=attrName);""!==attrType&&(node.attrType=attrType);""!==nameLen&&(node.name=nameLen);return node},parseSubNode:function(name,node,subNode){if(!0===subNode.singleProperty)name=subNode.propertyList[0],Array.isArray(name)?(node[subNode.name]=subNode,subNode.a=name):node[subNode.name]=name;else if("Connections"===name&&"C"===subNode.name){var array=[];subNode.propertyList.forEach(function(property,i){0!==i&&array.push(property)});void 0===node.connections&&(node.connections=
[]);node.connections.push(array)}else if("Properties70"===subNode.name)Object.keys(subNode).forEach(function(key){node[key]=subNode[key]});else if("Properties70"===name&&"P"===subNode.name){name=subNode.propertyList[0];var innerPropType1=subNode.propertyList[1],innerPropType2=subNode.propertyList[2],innerPropFlag=subNode.propertyList[3];0===name.indexOf("Lcl ")&&(name=name.replace("Lcl ","Lcl_"));0===innerPropType1.indexOf("Lcl ")&&(innerPropType1=innerPropType1.replace("Lcl ","Lcl_"));var innerPropValue=
"Color"===innerPropType1||"ColorRGB"===innerPropType1||"Vector"===innerPropType1||"Vector3D"===innerPropType1||0===innerPropType1.indexOf("Lcl_")?[subNode.propertyList[4],subNode.propertyList[5],subNode.propertyList[6]]:subNode.propertyList[4];node[name]={type:innerPropType1,type2:innerPropType2,flag:innerPropFlag,value:innerPropValue}}else void 0===node[subNode.name]?"number"===typeof subNode.id?(node[subNode.name]={},node[subNode.name][subNode.id]=subNode):node[subNode.name]=subNode:"PoseNode"===
subNode.name?(Array.isArray(node[subNode.name])||(node[subNode.name]=[node[subNode.name]]),node[subNode.name].push(subNode)):void 0===node[subNode.name][subNode.id]&&(node[subNode.name][subNode.id]=subNode)},parseProperty:function(reader){var type=reader.getString(1);switch(type){case "C":return reader.getBoolean();case "D":return reader.getFloat64();case "F":return reader.getFloat32();case "I":return reader.getInt32();case "L":return reader.getInt64();case "R":return type=reader.getUint32(),reader.getArrayBuffer(type);
case "S":return type=reader.getUint32(),reader.getString(type);case "Y":return reader.getInt16();case "b":case "c":case "d":case "f":case "i":case "l":var arrayLength=reader.getUint32(),encoding=reader.getUint32(),compressedLength=reader.getUint32();if(0===encoding)switch(type){case "b":case "c":return reader.getBooleanArray(arrayLength);case "d":return reader.getFloat64Array(arrayLength);case "f":return reader.getFloat32Array(arrayLength);case "i":return reader.getInt32Array(arrayLength);case "l":return reader.getInt64Array(arrayLength)}"undefined"===
typeof Zlib&&console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js");reader=new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength)));reader=new BinaryReader(reader.decompress().buffer);switch(type){case "b":case "c":return reader.getBooleanArray(arrayLength);case "d":return reader.getFloat64Array(arrayLength);case "f":return reader.getFloat32Array(arrayLength);case "i":return reader.getInt32Array(arrayLength);
case "l":return reader.getInt64Array(arrayLength)}default:throw Error("THREE.FBXLoader: Unknown property type "+type);}}};BinaryReader.prototype={constructor:BinaryReader,getOffset:function(){return this.offset},size:function(){return this.dv.buffer.byteLength},skip:function(length){this.offset+=length},getBoolean:function(){return 1===(this.getUint8()&1)},getBooleanArray:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getBoolean());return a},getUint8:function(){var value=this.dv.getUint8(this.offset);
this.offset+=1;return value},getInt16:function(){var value=this.dv.getInt16(this.offset,this.littleEndian);this.offset+=2;return value},getInt32:function(){var value=this.dv.getInt32(this.offset,this.littleEndian);this.offset+=4;return value},getInt32Array:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getInt32());return a},getUint32:function(){var value=this.dv.getUint32(this.offset,this.littleEndian);this.offset+=4;return value},getInt64:function(){if(this.littleEndian){var low=this.getUint32();
var high=this.getUint32()}else high=this.getUint32(),low=this.getUint32();return high&2147483648?(high=~high&4294967295,low=~low&4294967295,4294967295===low&&(high=high+1&4294967295),-(4294967296*high+(low+1&4294967295))):4294967296*high+low},getInt64Array:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getInt64());return a},getUint64:function(){if(this.littleEndian){var low=this.getUint32();var high=this.getUint32()}else high=this.getUint32(),low=this.getUint32();return 4294967296*high+low},
getFloat32:function(){var value=this.dv.getFloat32(this.offset,this.littleEndian);this.offset+=4;return value},getFloat32Array:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getFloat32());return a},getFloat64:function(){var value=this.dv.getFloat64(this.offset,this.littleEndian);this.offset+=8;return value},getFloat64Array:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getFloat64());return a},getArrayBuffer:function(size){var value=this.dv.buffer.slice(this.offset,this.offset+size);
this.offset+=size;return value},getString:function(size){for(var a=[],i=0;i<size;i++)a[i]=this.getUint8();size=a.indexOf(0);0<=size&&(a=a.slice(0,size));return THREE.LoaderUtils.decodeText(new Uint8Array(a))}};FBXTree.prototype={constructor:FBXTree,add:function(key,val){this[key]=val}};var dataArray=[],tempMat=new THREE.Matrix4,tempEuler=new THREE.Euler,tempVec=new THREE.Vector3,translation=new THREE.Vector3,rotation=new THREE.Matrix4;return FBXLoader}()}
//# sourceMappingURL=module$node_modules$aframe_extras$lib$FBXLoader.js.map
