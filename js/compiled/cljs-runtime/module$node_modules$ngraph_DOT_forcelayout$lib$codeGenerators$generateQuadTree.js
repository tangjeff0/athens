shadow$provide.module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$generateQuadTree=function(global,require,module,exports){function generateQuadTreeFunctionBody(dimension){function assignQuads(indent){for(var quads=[],i=0;i<quadCount;++i)quads.push(indent+"quad"+i+" \x3d null;");return quads.join("\n")}var pattern=createPatternBuilder(dimension),quadCount=Math.pow(2,dimension);return"\n\n/**\n * Our implementation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack \x3d [];\n    this.popIdx \x3d 0;\n}\n\nInsertStack.prototype \x3d {\n    isEmpty: function() {\n        return this.popIdx \x3d\x3d\x3d 0;\n    },\n    push: function (node, body) {\n        var item \x3d this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressure: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] \x3d new InsertStackElement(node, body);\n        } else {\n            item.node \x3d node;\n            item.body \x3d body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx \x3e 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx \x3d 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node \x3d node; // QuadTree node\n    this.body \x3d body; // physical body which needs to be inserted to node\n}\n\n\nfunction QuadNode() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain bodies:\n  this.body \x3d null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n"+
(assignQuads("  this.")+"\n\n  // Total mass of current node\n  this.mass \x3d 0;\n\n  // Center of mass coordinates\n  "+pattern("this.mass_{var} \x3d 0;",{indent:2})+"\n\n  // bounding box coordinates\n  "+pattern("this.min_{var} \x3d 0;",{indent:2})+"\n  "+pattern("this.max_{var} \x3d 0;",{indent:2})+"\n}\n\n\nfunction createQuadTree(options, random) {\n  options \x3d options || {};\n  options.gravity \x3d typeof options.gravity \x3d\x3d\x3d 'number' ? options.gravity : -1;\n  options.theta \x3d typeof options.theta \x3d\x3d\x3d 'number' ? options.theta : 0.8;\n\n  var gravity \x3d options.gravity;\n  var updateQueue \x3d [];\n  var insertStack \x3d new InsertStack();\n  var theta \x3d options.theta;\n\n  var nodesCache \x3d [];\n  var currentInCache \x3d 0;\n  var root \x3d newNode();\n\n  return {\n    insertBodies: insertBodies,\n\n    /**\n     * Gets root node if it is present\n     */\n    getRoot: function() {\n      return root;\n    },\n\n    updateBodyForce: update,\n\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity \x3d\x3d\x3d 'number') {\n          gravity \x3d newOptions.gravity;\n        }\n        if (typeof newOptions.theta \x3d\x3d\x3d 'number') {\n          theta \x3d newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node \x3d nodesCache[currentInCache];\n    if (node) {\n")+
assignQuads("      node.")+"\n      node.body \x3d null;\n      node.mass \x3d "+pattern("node.mass_{var} \x3d ",{join:""})+"0;\n      "+pattern("node.min_{var} \x3d node.max_{var} \x3d ",{join:""})+"0;\n    } else {\n      node \x3d new QuadNode();\n      nodesCache[currentInCache] \x3d node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue \x3d updateQueue;\n    var v;\n    "+pattern("var d{var};",{indent:4})+"\n    var r; \n    "+pattern("var f{var} \x3d 0;",
{indent:4})+"\n    var queueLength \x3d 1;\n    var shiftIdx \x3d 0;\n    var pushIdx \x3d 1;\n\n    queue[0] \x3d root;\n\n    while (queueLength) {\n      var node \x3d queue[shiftIdx];\n      var body \x3d node.body;\n\n      queueLength -\x3d 1;\n      shiftIdx +\x3d 1;\n      var differentBody \x3d (body !\x3d\x3d sourceBody);\n      if (body \x26\x26 differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        "+
pattern("d{var} \x3d body.pos.{var} - sourceBody.pos.{var};",{indent:8})+"\n        r \x3d Math.sqrt("+pattern("d{var} * d{var}",{join:" + "})+");\n\n        if (r \x3d\x3d\x3d 0) {\n          // Poor man's protection against zero distance.\n          "+pattern("d{var} \x3d (random.nextDouble() - 0.5) / 50;",{indent:10})+"\n          r \x3d Math.sqrt("+pattern("d{var} * d{var}",{join:" + "})+");\n        }\n\n        // This is standard gravitation force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v \x3d gravity * body.mass * sourceBody.mass / (r * r * r);\n        "+
pattern("f{var} +\x3d v * d{var};",{indent:8})+"\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        "+pattern("d{var} \x3d node.mass_{var} / node.mass - sourceBody.pos.{var};",{indent:8})+"\n        r \x3d Math.sqrt("+pattern("d{var} * d{var}",{join:" + "})+");\n\n        if (r \x3d\x3d\x3d 0) {\n          // Sorry about code duplication. I don't want to create many functions\n          // right away. Just want to see performance first.\n          "+
pattern("d{var} \x3d (random.nextDouble() - 0.5) / 50;",{indent:10})+"\n          r \x3d Math.sqrt("+pattern("d{var} * d{var}",{join:" + "})+");\n        }\n        // If s / r \x3c Î¸, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.max_"+getVariableName(0)+" - node.min_"+getVariableName(0)+") / r \x3c theta) {\n          // in the if statement above we consider node's width only\n          // because the region was made into square during tree creation.\n          // Thus there is no difference between using width or height.\n          v \x3d gravity * node.mass * sourceBody.mass / (r * r * r);\n          "+
pattern("f{var} +\x3d v * d{var};",{indent:10})+"\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n"+function(){for(var indent=Array(11).join(" "),code=[],i=0;i<quadCount;++i)code.push(indent+("if (node.quad"+i+") {")),code.push(indent+("  queue[pushIdx] \x3d node.quad"+i+";")),code.push(indent+"  queueLength +\x3d 1;"),code.push(indent+"  pushIdx +\x3d 1;"),
code.push(indent+"}");return code.join("\n")}()+"\n        }\n      }\n    }\n\n    "+pattern("sourceBody.force.{var} +\x3d f{var};",{indent:4})+"\n  }\n\n  function insertBodies(bodies) {\n    "+pattern("var {var}min \x3d Number.MAX_VALUE;",{indent:4})+"\n    "+pattern("var {var}max \x3d Number.MIN_VALUE;",{indent:4})+"\n    var i \x3d bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    while (i--) {\n      var pos \x3d bodies[i].pos;\n      "+
pattern("if (pos.{var} \x3c {var}min) {var}min \x3d pos.{var};",{indent:6})+"\n      "+pattern("if (pos.{var} \x3e {var}max) {var}max \x3d pos.{var};",{indent:6})+"\n    }\n\n    // Makes the bounds square.\n    var maxSideLength \x3d -Infinity;\n    "+pattern("if ({var}max - {var}min \x3e maxSideLength) maxSideLength \x3d {var}max - {var}min ;",{indent:4})+"\n\n    currentInCache \x3d 0;\n    root \x3d newNode();\n    "+pattern("root.min_{var} \x3d {var}min;",{indent:4})+"\n    "+pattern("root.max_{var} \x3d {var}min + maxSideLength;",
{indent:4})+"\n\n    i \x3d bodies.length - 1;\n    if (i \x3e\x3d 0) {\n      root.body \x3d bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem \x3d insertStack.pop();\n      var node \x3d stackItem.node;\n      var body \x3d stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        "+
pattern("var {var} \x3d body.pos.{var};",{indent:8})+"\n        node.mass +\x3d body.mass;\n        "+pattern("node.mass_{var} +\x3d body.mass * {var};",{indent:8})+"\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx \x3d 0; // Assume we are in the 0's quad.\n        "+pattern("var min_{var} \x3d node.min_{var};",{indent:8})+"\n        "+pattern("var max_{var} \x3d (min_{var} + node.max_{var}) / 2;",{indent:8})+
"\n\n"+function(indentCount){var code=[];indentCount=Array(indentCount+1).join(" ");for(var i=0;i<dimension;++i)code.push(indentCount+("if ("+getVariableName(i)+" \x3e max_"+getVariableName(i)+") {")),code.push(indentCount+("  quadIdx \x3d quadIdx + "+Math.pow(2,i)+";")),code.push(indentCount+("  min_"+getVariableName(i)+" \x3d max_"+getVariableName(i)+";")),code.push(indentCount+("  max_"+getVariableName(i)+" \x3d node.max_"+getVariableName(i)+";")),code.push(indentCount+"}");return code.join("\n")}(8)+
"\n\n        var child \x3d getChild(node, quadIdx);\n\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child \x3d newNode();\n          "+pattern("child.min_{var} \x3d min_{var};",{indent:10})+"\n          "+pattern("child.max_{var} \x3d max_{var};",{indent:10})+"\n          child.body \x3d body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody \x3d node.body;\n        node.body \x3d null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount \x3d 3;\n          do {\n            var offset \x3d random.nextDouble();\n            "+
pattern("var d{var} \x3d (node.max_{var} - node.min_{var}) * offset;",{indent:12})+"\n\n            "+pattern("oldBody.pos.{var} \x3d node.min_{var} + d{var};",{indent:12})+"\n            retriesCount -\x3d 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount \x3e 0 \x26\x26 isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount \x3d\x3d\x3d 0 \x26\x26 isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n}\n\nfunction getChild(node, idx) {\n"+
function(){for(var code=[],i=0;i<quadCount;++i)code.push("  if (idx \x3d\x3d\x3d "+i+") return node.quad"+i+";");return code.join("\n")}()+"\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n"+function(){for(var code=[],i=0;i<quadCount;++i)code.push((0===i?"  ":"  else ")+"if (idx \x3d\x3d\x3d "+i+") node.quad"+i+" \x3d child;");return code.join("\n")}()+"\n}\n\nfunction isSamePosition(point1, point2) {\n  "+pattern("var d{var} \x3d Math.abs(point1.{var} - point2.{var});",{indent:2})+"\n\n  return "+
pattern("d{var} \x3c 1e-8",{join:" \x26\x26 "})+";\n}\n\nreturn createQuadTree;\n\n"}var createPatternBuilder=require("module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$createPatternBuilder"),getVariableName=require("module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$getVariableName");module.exports=function(dimension){dimension=generateQuadTreeFunctionBody(dimension);return(new Function(dimension))()};module.exports.generateQuadTreeFunctionBody=generateQuadTreeFunctionBody}
//# sourceMappingURL=module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$generateQuadTree.js.map
