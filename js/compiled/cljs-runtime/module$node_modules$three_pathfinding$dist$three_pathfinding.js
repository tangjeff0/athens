shadow$provide.module$node_modules$three_pathfinding$dist$three_pathfinding=function(global,require,module,exports){var e$jscomp$1=function(){};e$jscomp$1.computeCentroids=function(e){var n,r;var t=0;for(n=e.faces.length;t<n;t++)(r=e.faces[t]).centroid=new THREE.Vector3(0,0,0),r.centroid.add(e.vertices[r.a]),r.centroid.add(e.vertices[r.b]),r.centroid.add(e.vertices[r.c]),r.centroid.divideScalar(3)};e$jscomp$1.roundNumber=function(e,t){return Number(e.toFixed(t))};e$jscomp$1.sample=function(e){return e[Math.floor(Math.random()*
e.length)]};e$jscomp$1.mergeVertexIds=function(e$jscomp$0,t){var n=[];if(e$jscomp$0.forEach(function(e){0<=t.indexOf(e)&&n.push(e)}),2>n.length)return[];n.includes(e$jscomp$0[0])&&n.includes(e$jscomp$0[e$jscomp$0.length-1])&&e$jscomp$0.push(e$jscomp$0.shift());n.includes(t[0])&&n.includes(t[t.length-1])&&t.push(t.shift());n=[];e$jscomp$0.forEach(function(e){t.includes(e)&&n.push(e)});var r=n[1],o=n[0];for(e$jscomp$0=e$jscomp$0.slice();e$jscomp$0[0]!==r;)e$jscomp$0.push(e$jscomp$0.shift());r=0;for(var u=
t.slice();u[0]!==o;)if(u.push(u.shift()),10<r++)throw Error("Unexpected state");return u.shift(),u.pop(),e$jscomp$0=e$jscomp$0.concat(u)};e$jscomp$1.setPolygonCentroid=function(e$jscomp$0,t){var n=new THREE.Vector3,r=t.vertices;e$jscomp$0.vertexIds.forEach(function(e){n.add(r[e])});n.divideScalar(e$jscomp$0.vertexIds.length);e$jscomp$0.centroid.copy(n)};e$jscomp$1.cleanPolygon=function(e,t$jscomp$0){for(var n=[],r=t$jscomp$0.vertices,o=0;o<e.vertexIds.length;o++){var i,s,c=r[e.vertexIds[o]];0===o?
(i=e.vertexIds[1],s=e.vertexIds[e.vertexIds.length-1]):o===e.vertexIds.length-1?(i=e.vertexIds[0],s=e.vertexIds[e.vertexIds.length-2]):(i=e.vertexIds[o+1],s=e.vertexIds[o-1]);var u=r[s];var h=r[i].clone().sub(c);u=u.clone().sub(c);h=h.angleTo(u);if(h>Math.PI-.01&&h<Math.PI+.01){var f=[];e.neighbours.forEach(function(t){t.vertexIds.includes(e.vertexIds[o])||f.push(t)});e.neighbours=f}else n.push(e.vertexIds[o])}e.vertexIds=n;this.setPolygonCentroid(e,t$jscomp$0)};e$jscomp$1.isConvex=function(e$jscomp$0,
t){t=t.vertices;if(3>e$jscomp$0.vertexIds.length)return!1;for(var r=!0,o=[],i=0;i<e$jscomp$0.vertexIds.length;i++){var s,u,c=t[e$jscomp$0.vertexIds[i]];0===i?(s=t[e$jscomp$0.vertexIds[1]],u=t[e$jscomp$0.vertexIds[e$jscomp$0.vertexIds.length-1]]):i===e$jscomp$0.vertexIds.length-1?(s=t[e$jscomp$0.vertexIds[0]],u=t[e$jscomp$0.vertexIds[e$jscomp$0.vertexIds.length-2]]):(s=t[e$jscomp$0.vertexIds[i+1]],u=t[e$jscomp$0.vertexIds[i-1]]);var h=s.clone().sub(c);c=u.clone().sub(c);var d=h.angleTo(c);if(d===Math.PI||
0===d)return!1;h=h.cross(c).y;o.push(h)}return o.forEach(function(e){0===e&&(r=!1)}),o.forEach(0<o[0]?function(e){0>e&&(r=!1)}:function(e){0<e&&(r=!1)}),r};e$jscomp$1.distanceToSquared=function(e,t){var n=e.x-t.x,r=e.y-t.y;e=e.z-t.z;return n*n+r*r+e*e};e$jscomp$1.isPointInPoly=function(e,t){for(var n=!1,r=-1,o=e.length,i=o-1;++r<o;i=r)(e[r].z<=t.z&&t.z<e[i].z||e[i].z<=t.z&&t.z<e[r].z)&&t.x<(e[i].x-e[r].x)*(t.z-e[r].z)/(e[i].z-e[r].z)+e[r].x&&(n=!n);return n};e$jscomp$1.isVectorInPolygon=function(e$jscomp$0,
t,n){var r=1E5,o=-1E5,i=[];return t.vertexIds.forEach(function(e){r=Math.min(n[e].y,r);o=Math.max(n[e].y,o);i.push(n[e])}),!!(e$jscomp$0.y<o+.5&&e$jscomp$0.y>r-.5&&this.isPointInPoly(i,e$jscomp$0))};e$jscomp$1.triarea2=function(e,t,n){return(n.x-e.x)*(t.z-e.z)-(t.x-e.x)*(n.z-e.z)};e$jscomp$1.vequal=function(e,t){return 1E-5>this.distanceToSquared(e,t)};var t$jscomp$2=function(e){this.content=[];this.scoreFunction=e};t$jscomp$2.prototype.push=function(e){this.content.push(e);this.sinkDown(this.content.length-
1)};t$jscomp$2.prototype.pop=function(){var e=this.content[0],t=this.content.pop();return 0<this.content.length&&(this.content[0]=t,this.bubbleUp(0)),e};t$jscomp$2.prototype.remove=function(e){var t=this.content.indexOf(e),n=this.content.pop();t!==this.content.length-1&&(this.content[t]=n,this.scoreFunction(n)<this.scoreFunction(e)?this.sinkDown(t):this.bubbleUp(t))};t$jscomp$2.prototype.size=function(){return this.content.length};t$jscomp$2.prototype.rescoreElement=function(e){this.sinkDown(this.content.indexOf(e))};
t$jscomp$2.prototype.sinkDown=function(e){for(var t=this.content[e];0<e;){var n=(e+1>>1)-1,r=this.content[n];if(!(this.scoreFunction(t)<this.scoreFunction(r)))break;this.content[n]=t;this.content[e]=r;e=n}};t$jscomp$2.prototype.bubbleUp=function(e){for(var t=this.content.length,n=this.content[e],r=this.scoreFunction(n);;){var o=e+1<<1,i=o-1,s=null,u=void 0;i<t&&(u=this.scoreFunction(this.content[i]))<r&&(s=i);o<t&&this.scoreFunction(this.content[o])<(null===s?r:u)&&(s=o);if(null===s)break;this.content[e]=
this.content[s];this.content[s]=n;e=s}};var n$jscomp$1=function(){};n$jscomp$1.init=function(e){for(var t=0;t<e.length;t++){var n=e[t];n.f=0;n.g=0;n.h=0;n.cost=1;n.visited=!1;n.closed=!1;n.parent=null}};n$jscomp$1.cleanUp=function(e){for(var t=0;t<e.length;t++){var n=e[t];delete n.f;delete n.g;delete n.h;delete n.cost;delete n.visited;delete n.closed;delete n.parent}};n$jscomp$1.heap=function(){return new t$jscomp$2(function(e){return e.f})};n$jscomp$1.search=function(e,t,n){this.init(e);var r=this.heap();
for(r.push(t);0<r.size();){t=r.pop();if(t===n){e=t;for(n=[];e.parent;)n.push(e),e=e.parent;return this.cleanUp(n),n.reverse()}t.closed=!0;for(var u=this.neighbours(e,t),c=0,h=u.length;c<h;c++){var a=u[c];if(!a.closed){var d=t.g+a.cost,f=a.visited;if(!f||d<a.g){if(a.visited=!0,a.parent=t,!a.centroid||!n.centroid)throw Error("Unexpected state");a.h=a.h||this.heuristic(a.centroid,n.centroid);a.g=d;a.f=a.g+a.h;f?r.rescoreElement(a):r.push(a)}}}}return[]};n$jscomp$1.heuristic=function(t,n){return e$jscomp$1.distanceToSquared(t,
n)};n$jscomp$1.neighbours=function(e,t){for(var n=[],r=0;r<t.neighbours.length;r++)n.push(e[t.neighbours[r]]);return n};var r$jscomp$1=1,o$jscomp$1=function(){};o$jscomp$1.buildZone=function(t$jscomp$0){var n$jscomp$0=this;t$jscomp$0=this._buildNavigationMesh(t$jscomp$0);var o$jscomp$0={};t$jscomp$0.vertices.forEach(function(t){t.x=e$jscomp$1.roundNumber(t.x,2);t.y=e$jscomp$1.roundNumber(t.y,2);t.z=e$jscomp$1.roundNumber(t.z,2)});o$jscomp$0.vertices=t$jscomp$0.vertices;t$jscomp$0=this._buildPolygonGroups(t$jscomp$0);
o$jscomp$0.groups=[];var s=function(e,t){for(var n=0;n<e.length;n++)if(t===e[n])return n};return t$jscomp$0.forEach(function(t){var r=[];t.forEach(function(o){var i=o.neighbours.map(function(e){return s(t,e)}),u=o.neighbours.map(function(e){return n$jscomp$0._getSharedVerticesInOrder(o,e)});o.centroid.x=e$jscomp$1.roundNumber(o.centroid.x,2);o.centroid.y=e$jscomp$1.roundNumber(o.centroid.y,2);o.centroid.z=e$jscomp$1.roundNumber(o.centroid.z,2);r.push({id:s(t,o),neighbours:i,vertexIds:o.vertexIds,
centroid:o.centroid,portals:u})});o$jscomp$0.groups.push(r)}),o$jscomp$0};o$jscomp$1._buildNavigationMesh=function(t){return e$jscomp$1.computeCentroids(t),t.mergeVertices(),this._buildPolygonsFromGeometry(t)};o$jscomp$1._buildPolygonGroups=function(e$jscomp$0){var t$jscomp$0=[],n=0,r=function(e){e.neighbours.forEach(function(t){void 0===t.group&&(t.group=e.group,r(t))})};return e$jscomp$0.polygons.forEach(function(e){void 0===e.group&&(e.group=n++,r(e));t$jscomp$0[e.group]||(t$jscomp$0[e.group]=
[]);t$jscomp$0[e.group].push(e)}),t$jscomp$0};o$jscomp$1._buildPolygonNeighbours=function(e$jscomp$0,t,n){var r=new Set,o=n.get(e$jscomp$0.vertexIds[0]),i=n.get(e$jscomp$0.vertexIds[1]),s=n.get(e$jscomp$0.vertexIds[2]);o.forEach(function(e){(i.has(e)||s.has(e))&&r.add(t.polygons[e])});i.forEach(function(e){s.has(e)&&r.add(t.polygons[e])});e$jscomp$0.neighbours=Array.from(r)};o$jscomp$1._buildPolygonsFromGeometry=function(e$jscomp$0){for(var t=this,n=[],o=e$jscomp$0.vertices,i=e$jscomp$0.faceVertexUvs,
s=new Map,u=0;u<o.length;u++)s.set(u,new Set);e$jscomp$0.faces.forEach(function(e){n.push({id:r$jscomp$1++,vertexIds:[e.a,e.b,e.c],centroid:e.centroid,normal:e.normal,neighbours:[]});s.get(e.a).add(n.length-1);s.get(e.b).add(n.length-1);s.get(e.c).add(n.length-1)});var c={polygons:n,vertices:o,faceVertexUvs:i};return n.forEach(function(e){t._buildPolygonNeighbours(e,c,s)}),c};o$jscomp$1._getSharedVerticesInOrder=function(e$jscomp$0,t){e$jscomp$0=e$jscomp$0.vertexIds;var r=t.vertexIds,o=new Set;if(e$jscomp$0.forEach(function(e){r.includes(e)&&
o.add(e)}),2>o.size)return[];o.has(e$jscomp$0[0])&&o.has(e$jscomp$0[e$jscomp$0.length-1])&&e$jscomp$0.push(e$jscomp$0.shift());o.has(r[0])&&o.has(r[r.length-1])&&r.push(r.shift());var i=[];return e$jscomp$0.forEach(function(e){r.includes(e)&&i.push(e)}),i};var i$jscomp$0=function(){this.portals=[]};i$jscomp$0.prototype.push=function(e,t){void 0===t&&(t=e);this.portals.push({left:e,right:t})};i$jscomp$0.prototype.stringPull=function(){var t,o=this.portals,i=[],s,u=0,c=0;var n=o[0].left;var r=o[0].right;
i.push(t=o[0].left);for(s=1;s<o.length;s++){var a=o[s].left,d=o[s].right;if(0>=e$jscomp$1.triarea2(t,r,d)){if(!(e$jscomp$1.vequal(t,r)||0<e$jscomp$1.triarea2(t,n,d))){i.push(n);r=n=t=n;c=u=s=u;continue}r=d;c=s}0<=e$jscomp$1.triarea2(t,n,a)&&(e$jscomp$1.vequal(t,n)||0>e$jscomp$1.triarea2(t,r,a)?(n=a,u=s):(i.push(r),r=n=t=r,c=u=s=c))}return 0!==i.length&&e$jscomp$1.vequal(i[i.length-1],o[o.length-1].left)||i.push(o[o.length-1].left),this.path=i,i};var s$jscomp$0,u$jscomp$0,c$jscomp$0,h$jscomp$0,a$jscomp$0,
d$jscomp$0;global=function(){this.zones={}};global.createZone=function(e){return o$jscomp$1.buildZone(e)};global.prototype.setZoneData=function(e,t){this.zones[e]=t};global.prototype.getGroup=function(t$jscomp$1,n){if(!this.zones[t$jscomp$1])return null;var r=null,o=Math.pow(50,2);return this.zones[t$jscomp$1].groups.forEach(function(t$jscomp$0,i){t$jscomp$0.forEach(function(t){t=e$jscomp$1.distanceToSquared(t.centroid,n);t<o&&(r=i,o=t)})}),r};global.prototype.getRandomNode=function(t$jscomp$0,n,
r,o){if(!this.zones[t$jscomp$0])return new THREE.Vector3;r=r||null;o=o||0;var i=[];return this.zones[t$jscomp$0].groups[n].forEach(function(t){r&&o?e$jscomp$1.distanceToSquared(r,t.centroid)<o*o&&i.push(t.centroid):i.push(t.centroid)}),e$jscomp$1.sample(i)||new THREE.Vector3};global.prototype.getClosestNode=function(t,n$jscomp$0,r$jscomp$0,o){void 0===o&&(o=!1);var i=this.zones[n$jscomp$0].vertices,s=null,u=Infinity;return this.zones[n$jscomp$0].groups[r$jscomp$0].forEach(function(n){var r=e$jscomp$1.distanceToSquared(n.centroid,
t);r<u&&(!o||e$jscomp$1.isVectorInPolygon(t,n,i))&&(s=n,u=r)}),s};global.prototype.findPath=function(e$jscomp$0,t$jscomp$0,r,o){var s=this.zones[r].groups[o],u=this.zones[r].vertices,c=this.getClosestNode(e$jscomp$0,r,o);r=this.getClosestNode(t$jscomp$0,r,o,!0);if(!c||!r)return null;s=n$jscomp$1.search(s,c,r);c=function(e,t){for(var n=0;n<e.neighbours.length;n++)if(e.neighbours[n]===t.id)return e.portals[n]};r=new i$jscomp$0;r.push(e$jscomp$0);for(e$jscomp$0=0;e$jscomp$0<s.length;e$jscomp$0++)if(o=
s[e$jscomp$0+1])o=c(s[e$jscomp$0],o),r.push(u[o[0]],u[o[1]]);r.push(t$jscomp$0);r.stringPull();t$jscomp$0=r.path.map(function(e){return new THREE.Vector3(e.x,e.y,e.z)});return t$jscomp$0.shift(),t$jscomp$0};global.prototype.clampStep=(c$jscomp$0=new THREE.Vector3,h$jscomp$0=new THREE.Plane,a$jscomp$0=new THREE.Triangle,d$jscomp$0=new THREE.Vector3,function(e,t,n,r,o,i){e=this.zones[r].vertices;r=this.zones[r].groups[o];o=[n];var p={};p[n.id]=0;s$jscomp$0=void 0;d$jscomp$0.set(0,0,0);u$jscomp$0=Infinity;
h$jscomp$0.setFromCoplanarPoints(e[n.vertexIds[0]],e[n.vertexIds[1]],e[n.vertexIds[2]]);h$jscomp$0.projectPoint(t,c$jscomp$0);t.copy(c$jscomp$0);for(n=o.pop();n;n=o.pop()){a$jscomp$0.set(e[n.vertexIds[0]],e[n.vertexIds[1]],e[n.vertexIds[2]]);a$jscomp$0.closestPointToPoint(t,c$jscomp$0);c$jscomp$0.distanceToSquared(t)<u$jscomp$0&&(s$jscomp$0=n,d$jscomp$0.copy(c$jscomp$0),u$jscomp$0=c$jscomp$0.distanceToSquared(t));var x=p[n];if(!(2<x))for(var I=0;I<n.neighbours.length;I++){var b=r[n.neighbours[I]];
b.id in p||(o.push(b),p[b.id]=x+1)}}return i.copy(d$jscomp$0),s$jscomp$0});exports.Pathfinding=global}
//# sourceMappingURL=module$node_modules$three_pathfinding$dist$three_pathfinding.js.map
