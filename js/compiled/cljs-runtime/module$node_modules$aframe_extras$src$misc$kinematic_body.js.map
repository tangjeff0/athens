{
"version":3,
"file":"module$node_modules$aframe_extras$src$misc$kinematic_body.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/aframe-extras/src/misc/kinematic-body.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$aframe_extras$src$misc$kinematic_body\"] = function(global,require,module,exports) {\n/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nconst EPS = 0.000001;\n\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n\n  schema: {\n    mass:           { default: 5 },\n    radius:         { default: 1.3 },\n    linearDamping:  { default: 0.05 },\n    enableSlopes:   { default: true },\n    enableJumps:    { default: false },\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n\n    const el = this.el,\n        data = this.data,\n        position = (new CANNON.Vec3()).copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(\n      new CANNON.Sphere(data.radius),\n      new CANNON.Vec3(0, data.radius, 0)\n    );\n\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n\n  remove: function () {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function (t, dt) {\n    if (!dt) return;\n\n    const el = this.el;\n    const data = this.data\n    const body = this.body;\n\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n\n  step: (function () {\n    const velocity = new THREE.Vector3(),\n        normalizedVelocity = new THREE.Vector3(),\n        currentSurfaceNormal = new THREE.Vector3(),\n        groundNormal = new THREE.Vector3();\n\n    return function (t, dt) {\n      if (!dt) return;\n\n      let body = this.body,\n          data = this.data,\n          didCollide = false,\n          height, groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) { continue; }\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45\u00ba) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id\n            ? Math.abs(contact.rj.y + contact.bj.position.y)\n            : Math.abs(contact.ri.y + contact.bi.position.y);\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        }\n\n        // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45\u00ba.\n        velocity.projectOnPlane(groundNormal);\n\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }()),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function (groundBody, groundNormal) {\n    let ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n\n    ray = new CANNON.Ray(vFrom, vTo);\n    ray._updateDirection(); // TODO - Report bug.\n    ray.intersectBody(groundBody);\n\n    if (!ray.hasHit) return groundNormal;\n\n    // Compare ABS, in case we're projecting against the inside of the face.\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","AFRAME","registerComponent","dependencies","schema","mass","default","radius","linearDamping","enableSlopes","enableJumps","init","system","el","sceneEl","systems","physics","addComponent","data","position","CANNON","Vec3","copy","object3D","getWorldPosition","THREE","Vector3","body","Body","material","getMaterial","fixedRotation","addShape","Sphere","addBody","hasAttribute","console","warn","remove","removeBody","removeComponent","beforeStep","t","dt","velocity","set","getAttribute","step","normalizedVelocity","currentSurfaceNormal","groundNormal","didCollide","groundHeight","Infinity","contacts","getContacts","Math","min","maxInterval","i","contact","enabled","id","bi","ni","negate","bj","dot","y","projectOnPlane","height","abs","rj","ri","groundBody","normalize","raycastToGround","driver","world","add","gravity","scale","setAttribute","vFrom","vTo","clone","ray","Ray","_updateDirection","intersectBody","hasHit","hitNormal","result","hitNormalWorld"]
}
