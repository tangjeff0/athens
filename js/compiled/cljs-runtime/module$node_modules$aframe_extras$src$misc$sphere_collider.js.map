{
"version":3,
"file":"module$node_modules$aframe_extras$src$misc$sphere_collider.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/aframe-extras/src/misc/sphere-collider.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$aframe_extras$src$misc$sphere_collider\"] = function(global,require,module,exports) {\n/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {default: ''},\n    state: {default: 'collided'},\n    radius: {default: 0.05},\n    watch: {default: true}\n  },\n\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n\n  remove: function () {\n    this.pause();\n  },\n\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\n    }\n  },\n\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n\n  tick: (function () {\n    const position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        distanceMap = new Map();\n    return function () {\n      const el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh'),\n          collisions = [];\n      let colliderRadius;\n\n      if (!mesh) { return; }\n\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\n        .forEach(this.handleHit);\n\n      // Remove collision state from current element.\n      if (collisions.length === 0) { el.emit('hit', {el: null}); }\n\n      // Remove collision state from other elements.\n      this.collisions\n        .filter((el) => !distanceMap.has(el))\n        .forEach(this.handleHitEnd);\n\n      // Store new collisions\n      this.collisions = collisions;\n\n      // Bounding sphere collision detection\n      function intersect (el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) { return; }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) { return; }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) { return; }\n\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor (scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  })(),\n\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {el: targetEl});\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {el: targetEl});\n  }\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","AFRAME","registerComponent","schema","objects","default","state","radius","watch","init","observer","els","collisions","handleHit","bind","handleHitEnd","remove","pause","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","mesh","getObject3D","clear","object3D","getWorldPosition","getWorldScale","colliderRadius","Math","max","apply","toArray","forEach","intersect","isEntity","setFromObject","getSize","extent","x","y","z","sqrt","getCenter","distance","distanceTo","push","set","sort","a","b","get","length","emit","filter","has","targetEl","addState","removeState"]
}
