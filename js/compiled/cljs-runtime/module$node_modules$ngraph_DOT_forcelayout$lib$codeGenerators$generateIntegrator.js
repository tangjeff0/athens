shadow$provide.module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$generateIntegrator=function(global,require,module,exports){function generateIntegratorFunctionBody(dimension){dimension=createPatternBuilder(dimension);return"\n  var length \x3d bodies.length;\n  if (length \x3d\x3d\x3d 0) return 0;\n\n  "+dimension("var d{var} \x3d 0, t{var} \x3d 0;",{indent:2})+"\n\n  for (var i \x3d 0; i \x3c length; ++i) {\n    var body \x3d bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight \x26\x26 body.springCount) {\n      timeStep \x3d (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff \x3d timeStep / body.mass;\n\n    "+
dimension("body.velocity.{var} +\x3d coeff * body.force.{var};",{indent:4})+"\n    "+dimension("var v{var} \x3d body.velocity.{var};",{indent:4})+"\n    var v \x3d Math.sqrt("+dimension("v{var} * v{var}",{join:" + "})+");\n\n    if (v \x3e 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v \x3c\x3d 1 - we let velocity to fade out.\n      "+dimension("body.velocity.{var} \x3d v{var} / v;",{indent:6})+"\n    }\n\n    "+dimension("d{var} \x3d timeStep * body.velocity.{var};",
{indent:4})+"\n\n    "+dimension("body.pos.{var} +\x3d d{var};",{indent:4})+"\n\n    "+dimension("t{var} +\x3d Math.abs(d{var});",{indent:4})+"\n  }\n\n  return ("+dimension("t{var} * t{var}",{join:" + "})+")/length;\n"}var createPatternBuilder=require("module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$createPatternBuilder");module.exports=function(dimension){dimension=generateIntegratorFunctionBody(dimension);return new Function("bodies","timeStep","adaptiveTimeStepWeight",dimension)};
module.exports.generateIntegratorFunctionBody=generateIntegratorFunctionBody}
//# sourceMappingURL=module$node_modules$ngraph_DOT_forcelayout$lib$codeGenerators$generateIntegrator.js.map
